{"version":3,"sources":["../src/Live.js"],"names":["DEBOUNCE_DURATION","MONITOR_THROTTLE_DURATION","Math","max","parseInt","process","env","LIVE_THROTTLE","LiveSource","subscribeCollection","_callback","_collectionIdentifier","_predicate","subscribeRecord","_recordIdentifier","LiveProvider","constructor","namespace","sources","registerSource","source","push","collectionIdentifierIsValid","recordIdentifierIsValid","LiveMonitor","providers","extraRootValue","released","subscriptionReleasersByCounter","changeCallback","changeCounter","liveConditionsByCounter","handleChange","_reallyHandleChange","cb","counter","String","changeRootValue","liveCollection","bind","liveRecord","liveConditions","release","resetBefore","console","warn","onChange","callback","Error","setImmediate","leading","trailing","currentCounter","oldCounters","Object","keys","filter","n","oldCounter","releaser","cancel","Infinity","collectionIdentifier","predicate","provider","length","recordIdentifier","LiveCoordinator","subscribe","registerProvider","getMonitor","_parent","_args","_context","_info","monitor","liveAbort","e","iterator","throw","makeAsyncIteratorFromMonitor","onClose"],"mappings":"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","sourcesContent":["// @flow\n/* eslint-disable flowtype/no-weak-types */\nimport callbackToAsyncIterator from \"./callbackToAsyncIterator\";\nimport type { GraphQLResolveInfo } from \"graphql\";\nimport { throttle } from \"lodash\";\n\ntype SubscriptionReleaser = () => void;\ntype SubscriptionCallback = () => void;\n\ntype Predicate = (record: any) => boolean;\ntype PredicateGenerator = (data: any) => Predicate;\n\nconst DEBOUNCE_DURATION = 25;\n\nconst MONITOR_THROTTLE_DURATION = Math.max(\n  DEBOUNCE_DURATION + 1,\n  parseInt(process.env.LIVE_THROTTLE || \"\", 10) || 500\n);\n\n/*\n * Sources are long-lived (i.e. in \"watch\" mode you just re-use the same one\n * over and over) because there is no release for them\n */\nexport class LiveSource {\n  subscribeCollection(\n    _callback: SubscriptionCallback,\n    _collectionIdentifier: any,\n    _predicate?: Predicate\n  ): SubscriptionReleaser | null {\n    return null;\n  }\n\n  subscribeRecord(\n    _callback: SubscriptionCallback,\n    _collectionIdentifier: any,\n    _recordIdentifier: any\n  ): SubscriptionReleaser | null {\n    return null;\n  }\n}\n\n/*\n * Providers enable a namespace, perform validation, and track the sources used\n * by that namespace within one single schema build. The should not directly use\n * any long-lived features as they do not have an explicit \"release\"/\"close\"\n * command when a new schema is built.\n */\nexport class LiveProvider {\n  sources: Array<LiveSource>;\n  namespace: string;\n\n  constructor(namespace: string) {\n    this.namespace = namespace;\n    this.sources = [];\n  }\n\n  registerSource(source: LiveSource) {\n    this.sources.push(source);\n  }\n\n  collectionIdentifierIsValid(_collectionIdentifier: any): boolean {\n    return false;\n  }\n\n  recordIdentifierIsValid(\n    _collectionIdentifier: any,\n    _recordIdentifier: any\n  ): boolean {\n    return false;\n  }\n}\n\n/*\n * During a single execution of GraphQL (specifically a subscription request),\n * the LiveMonitor tracks the resources viewed and subscribes to updates in them.\n */\nexport class LiveMonitor {\n  released: boolean;\n  providers: { [namespace: string]: LiveProvider };\n  subscriptionReleasersByCounter: {\n    [counter: string]: (() => void)[],\n  };\n  liveConditionsByCounter: { [counter: string]: Array<PredicateGenerator> };\n  changeCallback: ((arg: any) => void) | null;\n  changeCounter: number;\n  extraRootValue: any;\n\n  handleChange: (() => void) | null;\n  _reallyHandleChange: (() => void) | null;\n  onChange: (callback: () => void) => () => void;\n\n  constructor(\n    providers: { [namespace: string]: LiveProvider },\n    extraRootValue: any\n  ) {\n    this.extraRootValue = extraRootValue;\n    this.released = false;\n    this.providers = providers;\n    this.subscriptionReleasersByCounter = {};\n    this.changeCallback = null;\n    this.changeCounter = 0;\n    this.liveConditionsByCounter = {};\n    this.handleChange = function () {\n      /* This function is throttled to ~25ms (see constructor); it's purpose is\n       * to bundle up all the changes that occur in a small window into the same\n       * handle change flow, so _reallyHandleChange doesn't get called twice in\n       * quick succession. _reallyHandleChange is then further throttled with a\n       * larger window, BUT it triggers on both leading and trailing edge,\n       * whereas this only triggers on the trailing edge.\n       */\n      if (this._reallyHandleChange) {\n        this._reallyHandleChange();\n      }\n    };\n\n    this._reallyHandleChange = function () {\n      // This function is throttled to MONITOR_THROTTLE_DURATION (see constructor)\n      if (this.changeCallback) {\n        // Convince Flow this won't suddenly become null\n        const cb = this.changeCallback;\n        const counter = this.changeCounter++;\n        /*\n         * In live queries we need to know when the current result set has\n         * finished being calculated so that we know we've received all the\n         * liveRecord / liveCollection calls and can release the out of date\n         * ones. To achieve this, we use a custom `subscribe` function which\n         * calls `rootValue.release()` once the result set has been calculated.\n         */\n        this.subscriptionReleasersByCounter[String(counter)] = [];\n        this.liveConditionsByCounter[String(counter)] = [];\n        const changeRootValue = {\n          ...this.extraRootValue,\n          counter,\n          liveCollection: this.liveCollection.bind(this, counter),\n          liveRecord: this.liveRecord.bind(this, counter),\n          liveConditions: this.liveConditionsByCounter[String(counter)],\n          release: () => {\n            // Despite it's name, this means that the execution has complete, which means we're actually releasing everything *before* this.\n            this.resetBefore(counter);\n          },\n        };\n        cb(changeRootValue);\n      } else {\n        // eslint-disable-next-line no-console\n        console.warn(\"Change occurred, but no-one was listening\");\n      }\n    };\n\n    this.onChange = function (callback: () => void) {\n      if (this.released) {\n        throw new Error(\"Monitors cannot be reused.\");\n      }\n      if (this.changeCallback) {\n        throw new Error(\"Already monitoring for changes\");\n      }\n      // Throttle to every 250ms\n      this.changeCallback = callback;\n      if (this.handleChange) {\n        setImmediate(this.handleChange);\n      }\n      return () => {\n        if (this.changeCallback === callback) {\n          this.changeCallback = null;\n        }\n        this.release();\n      };\n    };\n\n    this.handleChange = throttle(\n      this.handleChange.bind(this),\n      DEBOUNCE_DURATION,\n      {\n        leading: false,\n        trailing: true,\n      }\n    );\n    if (!this._reallyHandleChange) {\n      throw new Error(\"This is just to make flow happy\");\n    }\n    this._reallyHandleChange = throttle(\n      this._reallyHandleChange.bind(this),\n      MONITOR_THROTTLE_DURATION - DEBOUNCE_DURATION,\n      {\n        leading: true,\n        trailing: true,\n      }\n    );\n    this.onChange = this.onChange.bind(this);\n  }\n\n  resetBefore(currentCounter: number) {\n    // Clear out of date subscriptionReleasers\n    {\n      const oldCounters = Object.keys(\n        this.subscriptionReleasersByCounter\n      ).filter(n => parseInt(n, 10) < currentCounter);\n      for (const oldCounter of oldCounters) {\n        for (const releaser of this.subscriptionReleasersByCounter[\n          oldCounter\n        ]) {\n          releaser();\n        }\n        delete this.subscriptionReleasersByCounter[oldCounter];\n      }\n    }\n    // Clear out of date liveConditions\n    {\n      const oldCounters = Object.keys(this.liveConditionsByCounter).filter(\n        n => parseInt(n, 10) < currentCounter\n      );\n      for (const oldCounter of oldCounters) {\n        delete this.liveConditionsByCounter[oldCounter];\n      }\n    }\n  }\n\n  release() {\n    if (this.handleChange) {\n      // $FlowFixMe: throttled function\n      this.handleChange.cancel();\n    }\n    this.handleChange = null;\n    if (this._reallyHandleChange) {\n      // $FlowFixMe: throttled function\n      this._reallyHandleChange.cancel();\n    }\n    this._reallyHandleChange = null;\n    this.resetBefore(Infinity);\n    this.providers = {};\n    this.released = true;\n  }\n\n  liveCollection(\n    counter: number,\n    namespace: string,\n    collectionIdentifier: any,\n    predicate: (record: any) => boolean = () => true\n  ) {\n    const handleChange = this.handleChange;\n    if (this.released || !handleChange) {\n      return;\n    }\n    const provider = this.providers[namespace];\n    if (!provider || provider.sources.length === 0) return;\n    if (!provider.collectionIdentifierIsValid(collectionIdentifier)) {\n      throw new Error(\n        `Invalid collection identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`\n      );\n    }\n    for (const source of provider.sources) {\n      const releaser = source.subscribeCollection(\n        handleChange,\n        collectionIdentifier,\n        predicate\n      );\n      if (releaser) {\n        this.subscriptionReleasersByCounter[String(counter)].push(releaser);\n      }\n    }\n  }\n\n  liveRecord(\n    counter: number,\n    namespace: string,\n    collectionIdentifier: any,\n    recordIdentifier: any\n  ) {\n    const handleChange = this.handleChange;\n    if (this.released || !handleChange) {\n      return;\n    }\n    // TODO: if (recordIdentifier == null) {return}\n    const provider = this.providers[namespace];\n    if (!provider || provider.sources.length === 0) return;\n    if (!provider.collectionIdentifierIsValid(collectionIdentifier)) {\n      throw new Error(\n        `Invalid collection identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`\n      );\n    }\n    if (\n      !provider.recordIdentifierIsValid(collectionIdentifier, recordIdentifier)\n    ) {\n      throw new Error(\n        `Invalid record identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`\n      );\n    }\n    for (const source of provider.sources) {\n      const releaser = source.subscribeRecord(\n        handleChange,\n        collectionIdentifier,\n        recordIdentifier\n      );\n      if (releaser) {\n        this.subscriptionReleasersByCounter[String(counter)].push(releaser);\n      }\n    }\n  }\n}\n\n/*\n * There is one coordinator for each build of the GraphQL schema, it tracks the providers\n * and gives a handy `subscribe` method that can be used for live queries (assuming\n * that the `resolve` is provided the same as in a Query).\n */\nexport class LiveCoordinator {\n  providers: { [namespace: string]: LiveProvider };\n\n  constructor() {\n    this.providers = {};\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  registerProvider(provider: LiveProvider) {\n    const { namespace } = provider;\n    if (this.providers[namespace]) {\n      throw new Error(`Namespace ${namespace} already registered with Live`);\n    }\n    this.providers[namespace] = provider;\n  }\n\n  registerSource(namespace: string, source: LiveSource) {\n    if (!this.providers[namespace]) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `LiveProvider '${namespace}' is not registered, skipping live source.`\n      );\n      return;\n    }\n    this.providers[namespace].registerSource(source);\n  }\n\n  getMonitor(extraRootValue: any) {\n    return new LiveMonitor(this.providers, extraRootValue);\n  }\n\n  // Tell Flow that we're okay with overwriting this\n  subscribe: (\n    _parent: any,\n    _args: any,\n    context: any,\n    _info: GraphQLResolveInfo\n  ) => any;\n  subscribe(\n    _parent: any,\n    _args: any,\n    _context: any,\n    _info: GraphQLResolveInfo\n  ) {\n    const monitor = this.getMonitor({\n      liveAbort: e => {\n        if (iterator) iterator.throw(e);\n      },\n    });\n    const iterator = makeAsyncIteratorFromMonitor(monitor);\n    return iterator;\n  }\n}\n\nexport function makeAsyncIteratorFromMonitor(monitor: LiveMonitor) {\n  return callbackToAsyncIterator(monitor.onChange, {\n    onClose: release => {\n      if (release) release();\n    },\n  });\n}\n"],"file":"Live.js"}