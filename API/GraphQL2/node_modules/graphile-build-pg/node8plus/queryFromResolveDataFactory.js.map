{"version":3,"sources":["../src/queryFromResolveDataFactory.js"],"names":["identity","_","undefined","assertSafeName","name","Error","test","queryBuilderOptions","from","fromAlias","resolveData","inOptions","withBuilder","context","rootValue","pgQuery","pgAggregateQuery","pgNamedQueryContainer","pgNamedQuery","pgCursorPrefix","reallyRawCursorPrefix","pgDontUseAsterisk","calculateHasNextPage","calculateHasPreviousPage","usesCursor","explicitlyUsesCursor","length","push","query","queryBuilder","options","innerQueryBuilder","sql","fragment","build","onlyJsonField","getTableExpression","getTableAlias","buildWhereClause","forEach","preventAsterisk","useAsterisk","rawCursorPrefix","filter","QueryBuilder","i","l","generateNextPrevPageSql","sqlQueryAlias","canHaveCursorInWhere","queryHasBefore","queryHasFirst","offset","invert","sqlCommonUnbounded","sqlCommon","isForwardOrSymmetric","literal","buildWhereBoundClause","getSelectCursor","blank","value","limit","getFinalLimitAndOffset","getPgCursorPrefix","data","cursorPrefix","map","val","withPagination","withPaginationAsFields","withCursor","selectCursor","orderBy","getOrderByExpressionsAndDirections","expr","isOrderUnique","join","getFinalOffset","setCursorComparator","cursorValue","isAfter","badCursor","whereBound","orderByExpressionsAndDirections","rawPrefixes","slice","rawCursors","Array","isArray","sqlFilter","sqlCursors","sqlExpression","ascending","comparison","Number","sqlOldFilter","null","cursorValue1","getOffset","Math","max","haveFields","getSelectFieldsCount","identifier","Symbol","sqlSummaryAlias","compiledData","upper","queryHasAfter","lower","queryHasZeroLimit","getFinalLimit","first","queryHasLast","last","hasNextPage","hasPreviousPage","sqlWith","sqlFrom","fields","groups","Object","keys","groupName","queryCallbacks","containers","c","container","aggregatesSql","alias","jsonbBuildObject"],"mappings":"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,EAKEC,MAAM,GAAG,CALX,EAMEC,MAAM,GAAG,KANX,EAOE;AACA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEM,UAAMC,kBAAkB,GAAGtB,GAAG,CAACC,QAAS;AAC9C;AACA,OAAOJ,YAAY,CAACO,kBAAb,EAAkC,OAAMP,YAAY,CAACQ,aAAb,EAA6B,EAFtE;AAGA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACM,UAAMkB,SAAS,GAAGvB,GAAG,CAACC,QAAS;AACrC,EAAEqB,kBAAmB;AACrB,QAAQzB,YAAY,CAACS,gBAAb,CAA8B,CAACe,MAA/B,EAAuCA,MAAvC,EAA+CvB,OAA/C,CAAwD,EAF1D;AAIA;AACN;AACA;AACA;;AACM,UAAM0B,oBAAoB,GAAG,CAACH,MAAD,IAAWD,MAAM,KAAK,CAAnD;;AAEA,QAAI,CAACI,oBAAL,EAA2B;AACzB,2BAAOH,MAAP;AACA,2BAAOD,MAAM,GAAG,CAAhB,EAFyB,CAGzB;AACA;;AACA,aAAOpB,GAAG,CAACyB,OAAJ,CAAY,IAAZ,CAAP;AACD,KAND,MAMO,IAAIR,oBAAJ,EAA0B;AAC/B,2BAAOO,oBAAP;;AACA,UAAI,CAACN,cAAD,IAAmB,CAACC,aAAxB,EAAuC;AACrC,6BAAOK,oBAAP,EADqC,CAErC;;AACA,eAAOxB,GAAG,CAACyB,OAAJ,CAAY,KAAZ,CAAP;AACD,OAJD,MAIO,IAAIP,cAAc,IAAI,CAACC,aAAvB,EAAsC;AAC3C;AACV;AACA;AACA;AACA;AACA;AACA;AACA;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","sourcesContent":["// @flow\nimport QueryBuilder from \"./QueryBuilder\";\nimport type { QueryBuilderOptions } from \"./QueryBuilder\";\nimport type { RawAlias } from \"./QueryBuilder\";\nimport * as sql from \"pg-sql2\";\nimport type { SQL } from \"pg-sql2\";\nimport type { DataForType } from \"graphile-build\";\nimport isSafeInteger from \"lodash/isSafeInteger\";\nimport assert from \"assert\";\nimport { inspect } from \"util\";\n\n// eslint-disable-next-line flowtype/no-weak-types\ntype GraphQLContext = any;\n\nconst identity = _ => _ !== null && _ !== undefined;\n\nfunction assertSafeName(name: mixed) {\n  if (typeof name !== \"string\") {\n    throw new Error(\n      `Expected name to be a string; instead received '${inspect(name)}'`\n    );\n  }\n  if (!/^[@a-zA-Z0-9_]{1,63}$/.test(name)) {\n    throw new Error(\n      `Name '${name}' is not safe - either it is too long, too short, or has invalid characters`\n    );\n  }\n}\n\nexport default (queryBuilderOptions: QueryBuilderOptions = {}) =>\n  (\n    from: SQL,\n    fromAlias: ?SQL,\n    resolveData: DataForType,\n    inOptions: {\n      withPagination?: boolean,\n      withPaginationAsFields?: boolean,\n      asJson?: boolean,\n      asJsonAggregate?: boolean,\n      addNullCase?: boolean,\n      addNotDistinctFromNullCase?: boolean,\n      onlyJsonField?: boolean,\n      useAsterisk?: boolean,\n      withCursor?: boolean,\n    },\n    // TODO:v5: context is not optional\n    withBuilder?: ((builder: QueryBuilder) => void) | null | void,\n    context?: GraphQLContext = {},\n    rootValue?: any // eslint-disable-line flowtype/no-weak-types\n  ) => {\n    const {\n      pgQuery,\n      pgAggregateQuery, // Shorthand for using pgNamedQueryContainer/pgNamedQuery combo\n      pgNamedQueryContainer = [],\n      pgNamedQuery = [],\n      pgCursorPrefix: reallyRawCursorPrefix,\n      pgDontUseAsterisk,\n      calculateHasNextPage,\n      calculateHasPreviousPage,\n      usesCursor: explicitlyUsesCursor,\n    } = resolveData;\n    // Push a query container for aggregates\n    if ((pgAggregateQuery && pgAggregateQuery.length) || pgNamedQuery.length) {\n      pgNamedQueryContainer.push({\n        name: \"aggregates\",\n        query: ({ queryBuilder, options, innerQueryBuilder }) => sql.fragment`\\\n(\n  select ${innerQueryBuilder.build({ onlyJsonField: true })}\n  from ${queryBuilder.getTableExpression()} as ${queryBuilder.getTableAlias()}\n  where ${queryBuilder.buildWhereClause(false, false, options)}\n)`,\n      });\n    }\n    // Convert pgAggregateQuery to pgNamedQueryContainer/pgNamedQuery combo\n    if (pgAggregateQuery && pgAggregateQuery.length) {\n      // And a query for each previous query\n      pgAggregateQuery.forEach(query => {\n        pgNamedQuery.push({ name: \"aggregates\", query });\n      });\n    }\n\n    const preventAsterisk = pgDontUseAsterisk\n      ? pgDontUseAsterisk.length > 0\n      : false;\n    const options = {\n      ...inOptions,\n      // Allow pgDontUseAsterisk to override useAsterisk\n      useAsterisk: inOptions.useAsterisk && !preventAsterisk,\n    };\n\n    const usesCursor: boolean =\n      (explicitlyUsesCursor && explicitlyUsesCursor.length > 0) ||\n      (calculateHasNextPage && calculateHasNextPage.length > 0) ||\n      (calculateHasPreviousPage && calculateHasPreviousPage.length > 0) ||\n      false;\n    const rawCursorPrefix =\n      reallyRawCursorPrefix && reallyRawCursorPrefix.filter(identity);\n\n    const queryBuilder = new QueryBuilder(\n      queryBuilderOptions,\n      context,\n      rootValue\n    );\n    queryBuilder.from(from, fromAlias ? fromAlias : undefined);\n\n    if (withBuilder) {\n      withBuilder(queryBuilder);\n    }\n    if (pgQuery) {\n      for (let i = 0, l = pgQuery.length; i < l; i++) {\n        pgQuery[i](queryBuilder, resolveData);\n      }\n    }\n\n    function generateNextPrevPageSql(\n      sqlQueryAlias,\n      canHaveCursorInWhere,\n      queryHasBefore,\n      queryHasFirst,\n      offset = 0,\n      invert = false\n    ) {\n      /*\n       * Strap in, 'coz this function gets hairy!\n       *\n       * The point of this function is to return SQL which will resolve to a\n       * boolean true/false depending on whether or not there is a (invert ?\n       * \"previous\" : \"next\") page.\n       *\n       * Connections have before, after, first, last and offset.\n       * - Users are forbidden from setting both first and last.\n       * - Users are forbidden from setting both offset and last.\n       *\n       * Further there are two main modes of paginating, one works by adding a\n       * where clause (this is preferred, but is not always possible, and is\n       * indicated by `canHaveCursorInWhere === true`) and the other works using\n       * standard LIMIT/OFFSET SQL pagination (and is indicated by\n       * `canHaveCursorInWhere === false`).\n       *\n       * The following diagram shows a full collection of records, #, starting at\n       * START and ending at END. The key after, before, offset, first and last\n       * variables are shown. One thing not show is that it's possible to have\n       * fewer records between before and after than requested by first or last.\n       * Another detail not clearly show is that if there is no `after` then\n       * `START` is used, similarly if there is no `before` then `END` is used.\n       *\n       *   #################################################### < collection\n       *   ^      ^<-offset->^<-first->^      ^<-last->^      ^\n       *   |      |          |         |      |        |      |\n       *   |      |          +---------+      +--------+      |\n       *   |      |          |  DATA1           DATA2  |      |\n       *   |      |          |                         |      |\n       *   |      |          |                         |      |\n       *   |      |          +-------------------------+      |\n       *   |      |                     DATA3          |      |\n       *   |    after                                before   |\n       *   |                                                  |\n       * START                                               END\n       *\n       * We want one of the three DATA blocks:\n       *\n       * - If `first` is set, then we want DATA1.\n       * - If `last` is set then we want DATA2.\n       * - If neither is set then we want DATA3.\n       *\n       * (Remember: you cannot set both `first` and `last` at the same time.)\n       *\n       * When invert === false:\n       *\n       *   Note that both DATA2 and DATA3 end at the same point, and we only care\n       *   if there's data *after* the relevant DATA block, so really we only\n       *   care if the query specified `first` (`queryHasFirst`) which makes\n       *   things complex (ending at the end of DATA1), otherwise we can use\n       *   `before` as the bound (end of DATA2/DATA3).\n       *\n       * When invert === true:\n       *\n       *   Similarly, DATA1 and DATA3 start at the same point, and we're going\n       *   backwards so we only care if there's data *before* the DATA block, so\n       *   really we just need to know if the query set `last` or not, but since\n       *   this is inverted we call it `queryHasFirst`.\n       *\n       * When `invert` is false we're calculating `hasNextPage`, when true we're\n       * calculating `hasPreviousPage`.\n       *\n       * Because of the near-symmetry of requesting hasPreviousPage vs\n       * hasNextPage we always pretend we're determining `hasNextPage`, and we\n       * just invert everything.\n       */\n\n      const sqlCommonUnbounded = sql.fragment`\\\nselect 1\nfrom ${queryBuilder.getTableExpression()} as ${queryBuilder.getTableAlias()}`;\n      /*\n       * This variable is a fragment to go into an `EXISTS(...)` call (after some tweaks).\n       *\n       * The buildWhereClause takes three arguments:\n       *\n       * - includeLowerBound (we want this for hasNextPage but not hasPreviousPage)\n       * - includeUpperBound (we want this for hasPreviousPage but not hasNextPage)\n       * - options (specifically `{addNullCase, addNotDistinctFromNullCase}`) -\n       *   we just pass this through.\n       *\n       * So in hasNextPage mode (invert === false), this common SQL ends up\n       * representing the collection from `(after || START)` onwards with no\n       * upper bound. In hasPreviousPage mode (invert === true), it represents\n       * everything from `(before || END)` backwards, with no lower bound.\n       */\n      const sqlCommon = sql.fragment`\\\n${sqlCommonUnbounded}\nwhere ${queryBuilder.buildWhereClause(!invert, invert, options)}`;\n\n      /*\n       * Since the offset makes the diagram asymmetric, if offset === 0\n       * then the diagram is symmetric and things are simplified a little.\n       */\n      const isForwardOrSymmetric = !invert || offset === 0;\n\n      if (!isForwardOrSymmetric) {\n        assert(invert);\n        assert(offset > 0);\n        // We're looking for a previous page, and there's an offset, so lets just\n        // assume there's a previous page where offset is smaller.\n        return sql.literal(true);\n      } else if (canHaveCursorInWhere) {\n        assert(isForwardOrSymmetric);\n        if (!queryHasBefore && !queryHasFirst) {\n          assert(isForwardOrSymmetric);\n          // There can be no next page since there's no upper bound\n          return sql.literal(false);\n        } else if (queryHasBefore && !queryHasFirst) {\n          /*\n           * We invert the upper buildWhereBoundClause to only represent the data\n           * after `before`, then check if there's at least one record in that set.\n           *\n           * This only works if the `before` cursor can be represented in the\n           * SQL WHERE clause, otherwise we're doing limit/offset pagination\n           * which requires different logic. It also only works if there's no\n           * `first` clause, otherwise there could be a next page before the\n           * `before` clause.\n           */\n          return sql.fragment`\\\nexists(\n  ${sqlCommonUnbounded}\n  where ${queryBuilder.buildWhereClause(false, false, options)}\n  and not (${queryBuilder.buildWhereBoundClause(invert)})\n)`;\n        } else {\n          assert(queryHasFirst);\n          // queryHasBefore could be true or false.\n          /*\n           * There's a few ways that we could determine if there's a next page.\n           *\n           * If !queryHasBefore, we could COUNT(*) the number of rows in\n           * `sqlCommon` and see if it's larger than `first`:\n           * `(select count(*) > ${first} from (${sqlCommon}) __random_table_alias__)`\n           *\n           * If !queryHasBefore, we could build a subquery table of offsetData\n           * from sqlCommon and see if it contains any rows:\n           * `EXISTS(select 1 from (${sqlCommon} OFFSET ${first}) __random_table_alias__)`.\n           *\n           * We could see if there's at least one row in sqlCommon that's not\n           * already in our chosen result set.\n           *\n           * We've chosen the latter approach here because it doesn't place a limit\n           * on queryHasBefore.\n           */\n          // Drop the `first` limit, see if there are any records that aren't\n          // already in the list we've fetched.\n          return sql.fragment`\\\nexists(\n  ${sqlCommon}\n  and (${queryBuilder.getSelectCursor()})::text not in (select __cursor::text from ${sqlQueryAlias})\n  ${offset === 0 ? sql.blank : sql.fragment`offset ${sql.value(offset)}`}\n)`;\n        }\n      } else {\n        assert(!invert || offset === 0); // isForwardOrSymmetric\n        assert(!canHaveCursorInWhere);\n        // We're dealing with LIMIT/OFFSET pagination here, which means `natural`\n        // cursors, so the `queryBuilder` factors the before/after, first/last\n        // into the limit / offset.\n        const { limit } = queryBuilder.getFinalLimitAndOffset();\n\n        if (limit == null) {\n          // If paginating backwards, then offset > 0 has already been dealt\n          // with. Unbounded, so there's no next page.\n          return sql.fragment`false`;\n        } else if (invert) {\n          assert(offset === 0);\n          // Paginating backwards and there's no offset (which factors in before/after), so there's no previous page.\n          return sql.fragment`false`;\n        } else {\n          assert(!invert);\n          /*\n           * We're paginating forwards; either there's a before, there's a first,\n           * or both.\n           *\n           * We want to see if there's more than limit+offset records in sqlCommon.\n           */\n          return sql.fragment`\\\nexists(\n  ${sqlCommon}\n  offset ${sql.literal(limit + offset)}\n)`;\n        }\n      }\n    }\n    const getPgCursorPrefix = () =>\n      rawCursorPrefix && rawCursorPrefix.length > 0\n        ? rawCursorPrefix\n        : queryBuilder.data.cursorPrefix.map(val => sql.literal(val));\n    if (\n      options.withPagination ||\n      options.withPaginationAsFields ||\n      options.withCursor\n    ) {\n      // Sometimes we need a __cursor even if it's not a collection; e.g. to get the edge field on a mutation\n      if (usesCursor) {\n        queryBuilder.selectCursor((): SQL => {\n          const orderBy = queryBuilder\n            .getOrderByExpressionsAndDirections()\n            .map(([expr]) => expr);\n          if (queryBuilder.isOrderUnique() && orderBy.length > 0) {\n            return sql.fragment`json_build_array(${sql.join(\n              [\n                ...getPgCursorPrefix(),\n                sql.fragment`json_build_array(${sql.join(orderBy, \", \")})`,\n              ],\n              \", \"\n            )})`;\n          } else {\n            return sql.fragment`json_build_array(${sql.join(\n              getPgCursorPrefix(),\n              \", \"\n            )}, ${\n              /*\n               * NOTE[useAsterisk/row_number]: If we have useAsterisk then the\n               * query with limit offset is in a subquery, so our row_number()\n               * call doesn't know about it. Here we add the offset back in\n               * again. See matching NOTE in QueryBuilder.js.\n               */\n              options.useAsterisk\n                ? sql.fragment`${sql.literal(\n                    queryBuilder.getFinalOffset() || 0\n                  )} + `\n                : sql.fragment``\n            }(row_number() over (partition by 1)))`;\n          }\n        });\n      }\n    }\n    if (options.withPagination || options.withPaginationAsFields) {\n      queryBuilder.setCursorComparator((cursorValue, isAfter) => {\n        function badCursor() {\n          queryBuilder.whereBound(sql.fragment`false`, isAfter);\n        }\n        const orderByExpressionsAndDirections =\n          queryBuilder.getOrderByExpressionsAndDirections();\n        if (orderByExpressionsAndDirections.length > 0) {\n          if (!queryBuilder.isOrderUnique()) {\n            throw new Error(\n              \"The order supplied is not unique, so before/after cursors cannot be used. Please ensure the supplied order includes all the columns from the primary key or a unique constraint.\"\n            );\n          }\n          const rawPrefixes = cursorValue.slice(0, cursorValue.length - 1);\n          const rawCursors = cursorValue[cursorValue.length - 1];\n          if (rawPrefixes.length !== getPgCursorPrefix().length) {\n            badCursor();\n            return;\n          }\n          if (!Array.isArray(rawCursors)) {\n            badCursor();\n            return;\n          }\n          let sqlFilter = sql.fragment`false`;\n          const sqlCursors = rawCursors.map(val => sql.value(val));\n          for (\n            let i = orderByExpressionsAndDirections.length - 1;\n            i >= 0;\n            i--\n          ) {\n            const [sqlExpression, ascending] =\n              orderByExpressionsAndDirections[i];\n            // If ascending and isAfter then >\n            // If ascending and isBefore then <\n            const comparison =\n              Number(ascending) ^ Number(!isAfter)\n                ? sql.fragment`>`\n                : sql.fragment`<`;\n\n            const sqlOldFilter = sqlFilter;\n            sqlFilter = sql.fragment`\\\n(\\\n  (${sqlExpression} ${comparison} ${sqlCursors[i] || sql.null})\nOR\\\n  (\\\n    ${sqlExpression} = ${sqlCursors[i] || sql.null}\\\n  AND\\\n    ${sqlOldFilter}\\\n  )\\\n)`;\n          }\n\n          // Check the cursor prefixes apply\n          // TODO:v5: we should be able to do this in JS-land rather than SQL-land\n          sqlFilter = sql.fragment`(((${sql.join(\n            getPgCursorPrefix(),\n            \", \"\n          )}) = (${sql.join(\n            rawPrefixes.map(val => sql.value(val)),\n            \", \"\n          )})) AND (${sqlFilter}))`;\n          queryBuilder.whereBound(sqlFilter, isAfter);\n        } else if (\n          cursorValue[0] === \"natural\" &&\n          isSafeInteger(cursorValue[1]) &&\n          // $FlowFixMe: we know this is a number\n          cursorValue[1] >= 0\n        ) {\n          // $FlowFixMe: we know this is a number\n          const cursorValue1: number = cursorValue[1];\n          if (isAfter) {\n            queryBuilder.offset(() => cursorValue1);\n          } else {\n            queryBuilder.limit(() => {\n              const offset = queryBuilder.getOffset();\n              return Math.max(0, cursorValue1 - offset - 1);\n            });\n          }\n        } else {\n          throw new Error(\n            \"Cannot use 'before'/'after' without unique 'orderBy'\"\n          );\n        }\n      });\n\n      const query = queryBuilder.build(options);\n      const haveFields = queryBuilder.getSelectFieldsCount() > 0;\n      const sqlQueryAlias = sql.identifier(Symbol());\n      const sqlSummaryAlias = sql.identifier(Symbol());\n      //\n      // Tables should ALWAYS push their PK onto the order stack, if this isn't\n      // present then we're either dealing with a view or a table without a PK.\n      // Either way, we don't have anything to guarantee uniqueness so we need to\n      // fall back to limit/offset.\n      //\n      // TODO: support unique keys in PgAllRows etc\n      // TODO: add a warning for cursor-based pagination when using the fallback\n      // TODO: if it is a view maybe add a warning encouraging pgViewUniqueKey\n      const canHaveCursorInWhere =\n        queryBuilder.getOrderByExpressionsAndDirections().length > 0 &&\n        queryBuilder.isOrderUnique();\n      const queryHasBefore =\n        queryBuilder.compiledData.whereBound.upper.length > 0;\n      const queryHasAfter =\n        queryBuilder.compiledData.whereBound.lower.length > 0;\n      const queryHasZeroLimit = queryBuilder.getFinalLimit() === 0;\n      const queryHasFirst = isSafeInteger(queryBuilder.compiledData.first);\n      const queryHasLast = isSafeInteger(queryBuilder.compiledData.last);\n      const hasNextPage = queryHasZeroLimit\n        ? sql.literal(false)\n        : generateNextPrevPageSql(\n            sqlQueryAlias,\n            canHaveCursorInWhere,\n            queryHasBefore,\n            queryHasFirst,\n            queryBuilder.getFinalOffset() || 0\n          );\n      const hasPreviousPage = queryHasZeroLimit\n        ? sql.literal(false)\n        : generateNextPrevPageSql(\n            sqlQueryAlias,\n            canHaveCursorInWhere,\n            queryHasAfter,\n            queryHasLast,\n            queryBuilder.getFinalOffset() || 0,\n            true\n          );\n\n      const sqlWith = haveFields\n        ? sql.fragment`with ${sqlQueryAlias} as (${query}), ${sqlSummaryAlias} as (select json_agg(to_json(${sqlQueryAlias})) as data from ${sqlQueryAlias})`\n        : sql.fragment``;\n      const sqlFrom = sql.fragment``;\n      const fields: Array<[SQL, RawAlias]> = [];\n      if (haveFields) {\n        fields.push([\n          sql.fragment`coalesce((select ${sqlSummaryAlias}.data from ${sqlSummaryAlias}), '[]'::json)`,\n          \"data\",\n        ]);\n        if (calculateHasNextPage) {\n          fields.push([hasNextPage, \"hasNextPage\"]);\n        }\n        if (calculateHasPreviousPage) {\n          fields.push([hasPreviousPage, \"hasPreviousPage\"]);\n        }\n      }\n      if (pgNamedQuery && pgNamedQuery.length) {\n        const groups = {};\n        pgNamedQuery.forEach(({ name, query }) => {\n          assertSafeName(name);\n          if (!groups[name]) {\n            groups[name] = [];\n          }\n          groups[name].push(query);\n        });\n        Object.keys(groups).forEach(groupName => {\n          const queryCallbacks = groups[groupName];\n\n          // Get container\n          const containers = pgNamedQueryContainer.filter(\n            c => c.name === groupName\n          );\n          if (containers.length === 0) {\n            throw new Error(\n              `${queryCallbacks.length} pgNamedQuery entries with name: '${groupName}' existed, but there was no matching pgNamedQueryContainer.`\n            );\n          }\n          if (containers.length > 1) {\n            throw new Error(\n              `${containers.length} pgNamedQueryContainer entries with name: '${groupName}' existed, but there should be exactly one.`\n            );\n          }\n          const container = containers[0];\n\n          const innerQueryBuilder = new QueryBuilder(\n            queryBuilderOptions,\n            context,\n            rootValue\n          );\n          innerQueryBuilder.from(\n            queryBuilder.getTableExpression(),\n            queryBuilder.getTableAlias()\n          );\n\n          for (let i = 0, l = queryCallbacks.length; i < l; i++) {\n            queryCallbacks[i](innerQueryBuilder);\n          }\n\n          // Generate the SQL statement (e.g. `select ${innerQueryBuilder.build({onlyJsonField: true})} from ${queryBuilder.getTableExpression()} as ...`)\n          const aggregatesSql = container.query({\n            queryBuilder,\n            innerQueryBuilder,\n            options,\n          });\n\n          fields.push([aggregatesSql, groupName]);\n        });\n      }\n      if (options.withPaginationAsFields) {\n        return sql.fragment`${sqlWith} select ${sql.join(\n          fields.map(\n            ([expr, alias]) => sql.fragment`${expr} as ${sql.identifier(alias)}`\n          ),\n          \", \"\n        )} ${sqlFrom}`;\n      } else {\n        return sql.fragment`${sqlWith} select ${queryBuilder.jsonbBuildObject(\n          fields\n        )} ${sqlFrom}`;\n      }\n    } else {\n      const query = queryBuilder.build(options);\n      return query;\n    }\n  };\n"],"file":"queryFromResolveDataFactory.js"}