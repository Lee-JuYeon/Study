{"version":3,"sources":["../../src/plugins/PgComputedColumnsPlugin.js"],"names":["getComputedColumnDetails","build","table","proc","isStable","namespaceId","name","startsWith","argTypeIds","length","type","id","argTypes","reduce","prev","typeId","idx","argModes","push","pgIntrospectionResultsByKind","typeById","slice","some","class","isSelectable","pseudoColumnName","PgComputedColumnsPlugin","builder","pgSimpleCollections","hook","fields","context","scope","isPgRowType","isPgCompoundType","isInputType","pgIntrospection","fieldWithHooks","Self","kind","namespace","extend","introspectionResultsByKind","inflection","pgOmit","omit","pgMakeProcField","makeProcField","swallowError","describePgEntity","sqlCommentByAddingTags","tableType","Error","procedure","memo","computedColumnDetails","makeField","forceList","fieldName","computedColumnList","computedColumn","computed","e","simpleCollections","tags","hasConnections","hasSimpleCollections","returnsSet"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin, Build } from \"graphile-build\";\nimport type { PgClass, PgProc } from \"./PgIntrospectionPlugin\";\n\nexport const getComputedColumnDetails = (\n  build: Build,\n  table: PgClass,\n  proc: PgProc\n) => {\n  if (!proc.isStable) return null;\n  if (proc.namespaceId !== table.namespaceId) return null;\n  if (!proc.name.startsWith(`${table.name}_`)) return null;\n  if (proc.argTypeIds.length < 1) return null;\n  if (proc.argTypeIds[0] !== table.type.id) return null;\n\n  const argTypes = proc.argTypeIds.reduce((prev, typeId, idx) => {\n    if (\n      proc.argModes.length === 0 || // all args are `in`\n      proc.argModes[idx] === \"i\" || // this arg is `in`\n      proc.argModes[idx] === \"b\" // this arg is `inout`\n    ) {\n      prev.push(build.pgIntrospectionResultsByKind.typeById[typeId]);\n    }\n    return prev;\n  }, []);\n  if (\n    argTypes\n      .slice(1)\n      .some(type => type.type === \"c\" && type.class && type.class.isSelectable)\n  ) {\n    // Accepts two input tables? Skip.\n    return null;\n  }\n\n  const pseudoColumnName = proc.name.slice(table.name.length + 1);\n  return { argTypes, pseudoColumnName };\n};\n\nexport default (function PgComputedColumnsPlugin(\n  builder,\n  { pgSimpleCollections }\n) {\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        scope: {\n          isPgRowType,\n          isPgCompoundType,\n          isInputType,\n          pgIntrospection: table,\n        },\n        fieldWithHooks,\n        Self,\n      } = context;\n\n      if (\n        isInputType ||\n        !(isPgRowType || isPgCompoundType) ||\n        !table ||\n        table.kind !== \"class\" ||\n        !table.namespace\n      ) {\n        return fields;\n      }\n\n      const {\n        extend,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        inflection,\n        pgOmit: omit,\n        pgMakeProcField: makeProcField,\n        swallowError,\n        describePgEntity,\n        sqlCommentByAddingTags,\n      } = build;\n      const tableType = table.type;\n      if (!tableType) {\n        throw new Error(\"Could not determine the type for this table\");\n      }\n      return extend(\n        fields,\n        introspectionResultsByKind.procedure.reduce((memo, proc) => {\n          if (omit(proc, \"execute\")) return memo;\n          const computedColumnDetails = getComputedColumnDetails(\n            build,\n            table,\n            proc\n          );\n          if (!computedColumnDetails) return memo;\n          const { pseudoColumnName } = computedColumnDetails;\n          function makeField(forceList) {\n            const fieldName = forceList\n              ? inflection.computedColumnList(pseudoColumnName, proc, table)\n              : inflection.computedColumn(pseudoColumnName, proc, table);\n            try {\n              memo = extend(\n                memo,\n                {\n                  [fieldName]: makeProcField(fieldName, proc, build, {\n                    fieldWithHooks,\n                    computed: true,\n                    forceList,\n                  }),\n                },\n                `Adding computed column for ${describePgEntity(\n                  proc\n                )}. You can rename this field with a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                  proc,\n                  {\n                    fieldName: \"newNameHere\",\n                  }\n                )}`\n              );\n            } catch (e) {\n              swallowError(e);\n            }\n          }\n          const simpleCollections =\n            proc.tags.simpleCollections || pgSimpleCollections;\n          const hasConnections = simpleCollections !== \"only\";\n          const hasSimpleCollections =\n            simpleCollections === \"only\" || simpleCollections === \"both\";\n          if (!proc.returnsSet || hasConnections) {\n            makeField(false);\n          }\n          if (proc.returnsSet && hasSimpleCollections) {\n            makeField(true);\n          }\n          return memo;\n        }, {}),\n        `Adding computed column to '${Self.name}'`\n      );\n    },\n    [\"PgComputedColumns\"]\n  );\n}: Plugin);\n"],"file":"PgComputedColumnsPlugin.js"}