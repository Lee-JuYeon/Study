{"version":3,"sources":["../../src/plugins/PgConnectionArgFirstLastBeforeAfter.js"],"names":["base64Decode","str","Buffer","from","String","toString","PgConnectionArgs","builder","hook","args","build","context","extend","getTypeByName","graphql","GraphQLInt","scope","fieldName","isPgFieldConnection","isPgFieldSimpleCollection","pgFieldIntrospection","source","addArgDataGenerator","Self","kind","Cursor","connectionFirstLastBeforeAfter","first","offset","last","after","before","pgQuery","queryBuilder","addCursorConstraint","Error","cursor","isAfter","cursorValues","JSON","parse","addCursorCondition","e","description","wrapDescription","type","name"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nconst base64Decode = str => Buffer.from(String(str), \"base64\").toString(\"utf8\");\n\nexport default (function PgConnectionArgs(builder) {\n  builder.hook(\n    \"GraphQLObjectType:fields:field:args\",\n    (args, build, context) => {\n      const {\n        extend,\n        getTypeByName,\n        graphql: { GraphQLInt },\n      } = build;\n      const {\n        scope: {\n          fieldName,\n          isPgFieldConnection,\n          isPgFieldSimpleCollection,\n          pgFieldIntrospection: source,\n        },\n        addArgDataGenerator,\n        Self,\n      } = context;\n\n      if (\n        !(isPgFieldConnection || isPgFieldSimpleCollection) ||\n        !source ||\n        (source.kind !== \"class\" && source.kind !== \"procedure\")\n      ) {\n        return args;\n      }\n      const Cursor = getTypeByName(\"Cursor\");\n\n      addArgDataGenerator(function connectionFirstLastBeforeAfter({\n        first,\n        offset,\n        last,\n        after,\n        before,\n      }) {\n        return {\n          pgQuery: queryBuilder => {\n            if (first != null) {\n              queryBuilder.first(first);\n            }\n            if (offset != null) {\n              queryBuilder.offset(offset);\n            }\n            if (isPgFieldConnection) {\n              if (after != null) {\n                addCursorConstraint(after, true);\n              }\n              if (before != null) {\n                addCursorConstraint(before, false);\n              }\n              if (last != null) {\n                if (first != null) {\n                  throw new Error(\n                    \"We don't support setting both first and last\"\n                  );\n                }\n                if (offset != null) {\n                  throw new Error(\n                    \"We don't support setting both offset and last\"\n                  );\n                }\n                queryBuilder.last(last);\n              }\n            }\n\n            function addCursorConstraint(cursor, isAfter) {\n              try {\n                const cursorValues = JSON.parse(base64Decode(cursor));\n                return queryBuilder.addCursorCondition(cursorValues, isAfter);\n              } catch (e) {\n                throw new Error(\n                  \"Invalid cursor, please enter a cursor from a previous request, or null.\"\n                );\n              }\n            }\n          },\n        };\n      });\n\n      return extend(\n        args,\n        {\n          first: {\n            description: build.wrapDescription(\n              \"Only read the first `n` values of the set.\",\n              \"arg\"\n            ),\n            type: GraphQLInt,\n          },\n          ...(isPgFieldConnection\n            ? {\n                last: {\n                  description: build.wrapDescription(\n                    \"Only read the last `n` values of the set.\",\n                    \"arg\"\n                  ),\n                  type: GraphQLInt,\n                },\n              }\n            : null),\n          offset: {\n            description: build.wrapDescription(\n              isPgFieldConnection\n                ? \"Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`.\"\n                : \"Skip the first `n` values.\",\n              \"arg\"\n            ),\n            type: GraphQLInt,\n          },\n          ...(isPgFieldConnection\n            ? {\n                before: {\n                  description: build.wrapDescription(\n                    \"Read all values in the set before (above) this cursor.\",\n                    \"arg\"\n                  ),\n                  type: Cursor,\n                },\n                after: {\n                  description: build.wrapDescription(\n                    \"Read all values in the set after (below) this cursor.\",\n                    \"arg\"\n                  ),\n                  type: Cursor,\n                },\n              }\n            : null),\n        },\n        isPgFieldConnection\n          ? `Adding connection pagination args to field '${fieldName}' of '${Self.name}'`\n          : `Adding simple collection args to field '${fieldName}' of '${Self.name}'`\n      );\n    },\n    [\"PgConnectionArgFirstLastBeforeAfter\"]\n  );\n}: Plugin);\n"],"file":"PgConnectionArgFirstLastBeforeAfter.js"}