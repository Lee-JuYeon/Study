{"version":3,"sources":["../../src/plugins/PgRowNode.js"],"names":["PgRowNode","builder","subscriptions","hook","object","build","context","addNodeFetcherForTypeName","pgSql","sql","gql2pg","pgQueryFromResolveData","queryFromResolveData","pgOmit","omit","pgPrepareAndRun","scope","isPgRowType","pgIntrospection","table","namespace","sqlFullTableName","identifier","name","primaryKeyConstraint","primaryKeys","keyAttributes","data","identifiers","resolveContext","parsedResolveInfoFragment","ReturnType","resolveData","resolveInfo","pgClient","liveRecord","rootValue","length","Error","query","undefined","useAsterisk","queryBuilder","selectIdentifiers","forEach","key","idx","where","fragment","getTableAlias","type","typeModifier","text","values","compile","debugSql","enabled","rows","row","__identifiers","fields","nodeIdFieldName","getTypeAndIdentifiersFromNodeId","extend","parseResolveInfo","pgGetGqlTypeByTypeIdAndModifier","pgIntrospectionResultsByKind","introspectionResultsByKind","graphql","GraphQLNonNull","GraphQLID","inflection","describePgEntity","sqlCommentByAddingTags","isRootQuery","fieldWithHooks","class","reduce","memo","TableType","id","fieldName","tableNode","getDataFromParsedResolveInfoFragment","description","wrapDescription","args","resolve","parent","nodeId","Type","e","isPgNodeQuery","pgFieldIntrospection"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport debugSql from \"./debugSql\";\n\nexport default (async function PgRowNode(builder, { subscriptions }) {\n  builder.hook(\n    \"GraphQLObjectType\",\n    (object, build, context) => {\n      const {\n        addNodeFetcherForTypeName,\n        pgSql: sql,\n        gql2pg,\n        pgQueryFromResolveData: queryFromResolveData,\n        pgOmit: omit,\n        pgPrepareAndRun,\n      } = build;\n      const {\n        scope: { isPgRowType, pgIntrospection: table },\n      } = context;\n\n      if (!addNodeFetcherForTypeName) {\n        // Node plugin must be disabled.\n        return object;\n      }\n      if (!isPgRowType || !table.namespace || omit(table, \"read\")) {\n        return object;\n      }\n      const sqlFullTableName = sql.identifier(table.namespace.name, table.name);\n      const primaryKeyConstraint = table.primaryKeyConstraint;\n      if (!primaryKeyConstraint) {\n        return object;\n      }\n      const primaryKeys =\n        primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n\n      addNodeFetcherForTypeName(\n        object.name,\n        async (\n          data,\n          identifiers,\n          resolveContext,\n          parsedResolveInfoFragment,\n          ReturnType,\n          resolveData,\n          resolveInfo\n        ) => {\n          const { pgClient } = resolveContext;\n          const liveRecord =\n            resolveInfo &&\n            resolveInfo.rootValue &&\n            resolveInfo.rootValue.liveRecord;\n          if (identifiers.length !== primaryKeys.length) {\n            throw new Error(\"Invalid ID\");\n          }\n          const query = queryFromResolveData(\n            sqlFullTableName,\n            undefined,\n            resolveData,\n            {\n              useAsterisk: false, // Because it's only a single relation, no need\n            },\n            queryBuilder => {\n              if (subscriptions && table.primaryKeyConstraint) {\n                queryBuilder.selectIdentifiers(table);\n              }\n              primaryKeys.forEach((key, idx) => {\n                queryBuilder.where(\n                  sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                    key.name\n                  )} = ${gql2pg(\n                    identifiers[idx],\n                    primaryKeys[idx].type,\n                    primaryKeys[idx].typeModifier\n                  )}`\n                );\n              });\n            },\n            resolveContext,\n            resolveInfo && resolveInfo.rootValue\n          );\n          const { text, values } = sql.compile(query);\n          if (debugSql.enabled) debugSql(text);\n          const {\n            rows: [row],\n          } = await pgPrepareAndRun(pgClient, text, values);\n          if (subscriptions && liveRecord && row) {\n            liveRecord(\"pg\", table, row.__identifiers);\n          }\n          return row;\n        }\n      );\n      return object;\n    },\n    [\"PgRowNode\"]\n  );\n\n  builder.hook(\n    \"GraphQLObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        nodeIdFieldName,\n        getTypeAndIdentifiersFromNodeId,\n        extend,\n        parseResolveInfo,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n        gql2pg,\n        graphql: { GraphQLNonNull, GraphQLID },\n        inflection,\n        pgQueryFromResolveData: queryFromResolveData,\n        pgOmit: omit,\n        describePgEntity,\n        sqlCommentByAddingTags,\n        pgPrepareAndRun,\n      } = build;\n      const {\n        scope: { isRootQuery },\n        fieldWithHooks,\n      } = context;\n\n      if (!isRootQuery || !nodeIdFieldName) {\n        return fields;\n      }\n\n      return extend(\n        fields,\n        introspectionResultsByKind.class.reduce((memo, table) => {\n          // PERFORMANCE: These used to be .filter(...) calls\n          if (!table.namespace) return memo;\n          if (omit(table, \"read\")) return memo;\n\n          const TableType = pgGetGqlTypeByTypeIdAndModifier(\n            table.type.id,\n            null\n          );\n          const sqlFullTableName = sql.identifier(\n            table.namespace.name,\n            table.name\n          );\n          if (TableType) {\n            const primaryKeyConstraint = table.primaryKeyConstraint;\n            if (!primaryKeyConstraint) {\n              return memo;\n            }\n            const primaryKeys =\n              primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n            const fieldName = inflection.tableNode(table);\n            memo = extend(\n              memo,\n              {\n                [fieldName]: fieldWithHooks(\n                  fieldName,\n                  ({ getDataFromParsedResolveInfoFragment }) => {\n                    return {\n                      description: build.wrapDescription(\n                        `Reads a single \\`${TableType.name}\\` using its globally unique \\`ID\\`.`,\n                        \"field\"\n                      ),\n                      type: TableType,\n                      args: {\n                        [nodeIdFieldName]: {\n                          description: build.wrapDescription(\n                            `The globally unique \\`ID\\` to be used in selecting a single \\`${TableType.name}\\`.`,\n                            \"arg\"\n                          ),\n                          type: new GraphQLNonNull(GraphQLID),\n                        },\n                      },\n                      async resolve(parent, args, resolveContext, resolveInfo) {\n                        const { pgClient } = resolveContext;\n                        const liveRecord =\n                          resolveInfo.rootValue &&\n                          resolveInfo.rootValue.liveRecord;\n                        const nodeId = args[nodeIdFieldName];\n                        try {\n                          const { Type, identifiers } =\n                            getTypeAndIdentifiersFromNodeId(nodeId);\n                          if (Type !== TableType) {\n                            throw new Error(\"Mismatched type\");\n                          }\n                          if (identifiers.length !== primaryKeys.length) {\n                            throw new Error(\"Invalid ID\");\n                          }\n\n                          const parsedResolveInfoFragment =\n                            parseResolveInfo(resolveInfo);\n                          parsedResolveInfoFragment.args = args; // Allow overriding via makeWrapResolversPlugin\n                          const resolveData =\n                            getDataFromParsedResolveInfoFragment(\n                              parsedResolveInfoFragment,\n                              TableType\n                            );\n                          const query = queryFromResolveData(\n                            sqlFullTableName,\n                            undefined,\n                            resolveData,\n                            {\n                              useAsterisk: false, // Because it's only a single relation, no need\n                            },\n                            queryBuilder => {\n                              if (subscriptions && table.primaryKeyConstraint) {\n                                queryBuilder.selectIdentifiers(table);\n                              }\n                              primaryKeys.forEach((key, idx) => {\n                                queryBuilder.where(\n                                  sql.fragment`${queryBuilder.getTableAlias()}.${sql.identifier(\n                                    key.name\n                                  )} = ${gql2pg(\n                                    identifiers[idx],\n                                    primaryKeys[idx].type,\n                                    primaryKeys[idx].typeModifier\n                                  )}`\n                                );\n                              });\n                            },\n                            resolveContext,\n                            resolveInfo.rootValue\n                          );\n                          const { text, values } = sql.compile(query);\n                          if (debugSql.enabled) debugSql(text);\n                          const {\n                            rows: [row],\n                          } = await pgPrepareAndRun(pgClient, text, values);\n                          if (liveRecord && row) {\n                            liveRecord(\"pg\", table, row.__identifiers);\n                          }\n                          return row;\n                        } catch (e) {\n                          return null;\n                        }\n                      },\n                    };\n                  },\n                  {\n                    isPgNodeQuery: true,\n                    pgFieldIntrospection: table,\n                  }\n                ),\n              },\n              `Adding row by globally unique identifier field for ${describePgEntity(\n                table\n              )}. You can rename this table via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n                table,\n                { name: \"newNameHere\" }\n              )}`\n            );\n          }\n          return memo;\n        }, {}),\n        `Adding \"row by node ID\" fields to root Query type`\n      );\n    },\n    [\"PgRowNode\"]\n  );\n}: Plugin);\n"],"file":"PgRowNode.js"}