{"version":3,"sources":["../../src/plugins/PgOrderComputedColumnsPlugin.js"],"names":["PgOrderComputedColumnsPlugin","builder","hook","values","build","context","extend","inflection","pgOmit","omit","describePgEntity","pgIntrospectionResultsByKind","introspectionResultsByKind","pgSql","sql","scope","isPgRowSortEnum","pgIntrospection","table","kind","compatibleComputedColumns","procedure","reduce","memo","proc","tags","sortable","computedColumnDetails","pseudoColumnName","nonOptionalArgumentsCount","inputArgsCount","argDefaultsNum","returnsSet","returnType","typeById","returnTypeId","isPgArray","returnTypeTable","classById","classId","isRecordLike","id","isVoid","String","push","ascFieldName","orderByComputedColumnEnum","descFieldName","unique","isUnique","functionCall","queryBuilder","fragment","identifier","namespaceName","name","getTableAlias","value","alias","toLowerCase","specs"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport { getComputedColumnDetails } from \"./PgComputedColumnsPlugin\";\n\nexport default (function PgOrderComputedColumnsPlugin(builder) {\n  builder.hook(\n    \"GraphQLEnumType:values\",\n    (values, build, context) => {\n      const {\n        extend,\n        inflection,\n        pgOmit: omit,\n        describePgEntity,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        pgSql: sql,\n      } = build;\n      const {\n        scope: { isPgRowSortEnum, pgIntrospection: table },\n      } = context;\n      if (!isPgRowSortEnum || !table || table.kind !== \"class\") {\n        return values;\n      }\n\n      const compatibleComputedColumns =\n        introspectionResultsByKind.procedure.reduce((memo, proc) => {\n          /* ALSO SEE PgConditionComputedColumnPlugin */\n          // Must be marked @sortable\n          if (!proc.tags.sortable) return memo;\n\n          // Must not be omitted\n          if (omit(proc, \"execute\")) return memo;\n\n          // Must be a computed column\n          const computedColumnDetails = getComputedColumnDetails(\n            build,\n            table,\n            proc\n          );\n          if (!computedColumnDetails) return memo;\n          const { pseudoColumnName } = computedColumnDetails;\n\n          // Must have only one required argument\n          const nonOptionalArgumentsCount =\n            proc.inputArgsCount - proc.argDefaultsNum;\n          if (nonOptionalArgumentsCount > 1) {\n            return memo;\n          }\n\n          // Must return a scalar\n          if (proc.returnsSet) return memo;\n          const returnType =\n            introspectionResultsByKind.typeById[proc.returnTypeId];\n          if (returnType.isPgArray) return memo;\n          const returnTypeTable =\n            introspectionResultsByKind.classById[returnType.classId];\n          if (returnTypeTable) return memo;\n          const isRecordLike = returnType.id === \"2249\";\n          if (isRecordLike) return memo;\n          const isVoid = String(returnType.id) === \"2278\";\n          if (isVoid) return memo;\n\n          // Looks good\n          memo.push({ proc, pseudoColumnName });\n          return memo;\n        }, []);\n      return extend(\n        values,\n        compatibleComputedColumns.reduce((memo, { proc, pseudoColumnName }) => {\n          const ascFieldName = inflection.orderByComputedColumnEnum(\n            pseudoColumnName,\n            proc,\n            table,\n            true\n          );\n          const descFieldName = inflection.orderByComputedColumnEnum(\n            pseudoColumnName,\n            proc,\n            table,\n            false\n          );\n\n          const unique = !!proc.tags.isUnique;\n\n          const functionCall = ({ queryBuilder }) =>\n            sql.fragment`(${sql.identifier(\n              proc.namespaceName,\n              proc.name\n            )}(${queryBuilder.getTableAlias()}))`;\n\n          memo = extend(\n            memo,\n            {\n              [ascFieldName]: {\n                value: {\n                  alias: ascFieldName.toLowerCase(),\n                  specs: [[functionCall, true]],\n                  unique,\n                },\n              },\n            },\n            `Adding ascending orderBy enum value for ${describePgEntity(\n              proc\n            )}. You can rename this field by removing the '@sortable' smart comment from the function.`\n          );\n          memo = extend(\n            memo,\n            {\n              [descFieldName]: {\n                value: {\n                  alias: descFieldName.toLowerCase(),\n                  specs: [[functionCall, false]],\n                  unique,\n                },\n              },\n            },\n            `Adding descending orderBy enum value for ${describePgEntity(\n              proc\n            )}. You can rename this field by removing the '@sortable' smart comment from the function.`\n          );\n          return memo;\n        }, {}),\n        `Adding order values from table '${table.name}'`\n      );\n    },\n    [\"PgOrderComputedColumns\"]\n  );\n}: Plugin);\n"],"file":"PgOrderComputedColumnsPlugin.js"}