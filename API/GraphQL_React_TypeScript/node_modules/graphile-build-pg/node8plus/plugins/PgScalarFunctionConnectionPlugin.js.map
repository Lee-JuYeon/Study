{"version":3,"sources":["../../src/plugins/PgScalarFunctionConnectionPlugin.js"],"names":["base64","str","Buffer","from","String","toString","PgScalarFunctionConnectionPlugin","builder","hook","_","build","newWithHooks","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","graphql","GraphQLObjectType","GraphQLNonNull","GraphQLList","GraphQLString","inflection","pgOmit","omit","describePgEntity","sqlCommentByAddingTags","pgField","Cursor","procedure","forEach","proc","returnsSet","namespace","returnType","typeById","returnTypeId","returnTypeTable","classById","classId","id","NodeType","EdgeType","name","scalarFunctionEdge","description","wrapDescription","fields","fieldWithHooks","cursor","addDataGenerator","usesCursor","type","resolve","data","JSON","stringify","__cursor","isCursorField","node","value","__origin","isEdgeType","nodeType","pgIntrospection","scalarFunctionConnection","nodes","map","entry","edges","hoistCursor","isConnectionType","isPgRowConnectionType","edgeType"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\n\nconst base64 = str => Buffer.from(String(str)).toString(\"base64\");\n\nexport default (function PgScalarFunctionConnectionPlugin(builder) {\n  builder.hook(\n    \"init\",\n    (_, build) => {\n      const {\n        newWithHooks,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        getTypeByName,\n        pgGetGqlTypeByTypeIdAndModifier,\n        graphql: {\n          GraphQLObjectType,\n          GraphQLNonNull,\n          GraphQLList,\n          GraphQLString,\n        },\n        inflection,\n        pgOmit: omit,\n        describePgEntity,\n        sqlCommentByAddingTags,\n        pgField,\n      } = build;\n\n      const Cursor = getTypeByName(\"Cursor\");\n      introspectionResultsByKind.procedure.forEach(proc => {\n        // PERFORMANCE: These used to be .filter(...) calls\n        if (!proc.returnsSet) return;\n        if (!proc.namespace) return;\n        if (omit(proc, \"execute\")) return;\n\n        const returnType =\n          introspectionResultsByKind.typeById[proc.returnTypeId];\n        const returnTypeTable =\n          introspectionResultsByKind.classById[returnType.classId];\n        if (returnTypeTable) {\n          // Just use the standard table connection from PgTablesPlugin\n          return;\n        }\n        if (returnType.id === \"2249\") {\n          // Defer handling to PgRecordFunctionConnectionPlugin\n          return;\n        }\n        // TODO: PG10 doesn't support the equivalent of pg_attribute.atttypemod\n        // on function arguments and return types, however maybe a later\n        // version of PG will?\n        const NodeType =\n          pgGetGqlTypeByTypeIdAndModifier(returnType.id, null) || GraphQLString;\n        const EdgeType = newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.scalarFunctionEdge(proc),\n            description: build.wrapDescription(\n              `A \\`${NodeType.name}\\` edge in the connection.`,\n              \"type\"\n            ),\n            fields: ({ fieldWithHooks }) => {\n              return {\n                cursor: fieldWithHooks(\n                  \"cursor\",\n                  ({ addDataGenerator }) => {\n                    addDataGenerator(() => ({\n                      usesCursor: [true],\n                    }));\n                    return {\n                      description: build.wrapDescription(\n                        \"A cursor for use in pagination.\",\n                        \"field\"\n                      ),\n                      type: Cursor,\n                      resolve(data) {\n                        return base64(JSON.stringify(data.__cursor));\n                      },\n                    };\n                  },\n                  {\n                    isCursorField: true,\n                  }\n                ),\n                node: {\n                  description: build.wrapDescription(\n                    `The \\`${NodeType.name}\\` at the end of the edge.`,\n                    \"field\"\n                  ),\n                  type: NodeType,\n                  resolve(data) {\n                    return data.value;\n                  },\n                },\n              };\n            },\n          },\n          {\n            __origin: `Adding function result edge type for ${describePgEntity(\n              proc\n            )}. You can rename the function's GraphQL field (and its dependent types) via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            isEdgeType: true,\n            nodeType: NodeType,\n            pgIntrospection: proc,\n          }\n        );\n\n        /*const ConnectionType = */\n        newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.scalarFunctionConnection(proc),\n            description: build.wrapDescription(\n              `A connection to a list of \\`${NodeType.name}\\` values.`,\n              \"type\"\n            ),\n            fields: ({ fieldWithHooks }) => {\n              return {\n                nodes: pgField(build, fieldWithHooks, \"nodes\", {\n                  description: build.wrapDescription(\n                    `A list of \\`${NodeType.name}\\` objects.`,\n                    \"field\"\n                  ),\n                  type: new GraphQLNonNull(new GraphQLList(NodeType)),\n                  resolve(data) {\n                    return data.data.map(entry => entry.value);\n                  },\n                }),\n                edges: pgField(\n                  build,\n                  fieldWithHooks,\n                  \"edges\",\n                  {\n                    description: build.wrapDescription(\n                      `A list of edges which contains the \\`${NodeType.name}\\` and cursor to aid in pagination.`,\n                      \"field\"\n                    ),\n                    type: new GraphQLNonNull(\n                      new GraphQLList(new GraphQLNonNull(EdgeType))\n                    ),\n                    resolve(data) {\n                      return data.data;\n                    },\n                  },\n                  {},\n                  false,\n                  {\n                    hoistCursor: true,\n                  }\n                ),\n              };\n            },\n          },\n          {\n            __origin: `Adding function connection type for ${describePgEntity(\n              proc\n            )}. You can rename the function's GraphQL field (and its dependent types) via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            isConnectionType: true,\n            isPgRowConnectionType: true,\n            edgeType: EdgeType,\n            nodeType: NodeType,\n            pgIntrospection: proc,\n          }\n        );\n      });\n      return _;\n    },\n    [\"PgScalarFunctionConnection\"],\n    [],\n    [\"PgTypes\"]\n  );\n}: Plugin);\n"],"file":"PgScalarFunctionConnectionPlugin.js"}