"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fieldHelpers_1 = require("./fieldHelpers");
// TODO:v5: Remove
const recurseDataGeneratorsWorkaroundFieldByType = new Map();
function makeExtendSchemaPlugin(generator, uniqueId = String(Math.random()).slice(2)) {
    let graphql;
    return (builder, schemaOptions) => {
        // Add stuff to the schema
        builder.hook("build", build => {
            // Extract GraphQL into the scope so that our other functions can use it.
            graphql = build.graphql;
            const { addType } = build;
            const { GraphQLEnumType, GraphQLInputObjectType, GraphQLObjectType, GraphQLScalarType, GraphQLDirective, GraphQLUnionType, GraphQLInterfaceType, } = graphql;
            const { typeDefs, resolvers = {} } = typeof generator === "function"
                ? generator(build, schemaOptions)
                : generator;
            const typeDefsArr = Array.isArray(typeDefs) ? typeDefs : [typeDefs];
            const mergedTypeDefinitions = typeDefsArr.reduce((definitions, typeDef) => {
                if (!typeDef || typeDef.kind !== "Document") {
                    throw new Error("The first argument to makeExtendSchemaPlugin must be generated by the `gql` helper, or be an array of the same.");
                }
                definitions.push(...typeDef.definitions);
                return definitions;
            }, []);
            const typeExtensions = {
                GraphQLSchema: {
                    directives: [],
                    types: [],
                },
                GraphQLInputObjectType: {},
                GraphQLObjectType: {},
                GraphQLInterfaceType: {},
            };
            const newTypes = [];
            mergedTypeDefinitions.forEach(definition => {
                if (definition.kind === "EnumTypeDefinition") {
                    newTypes.push({
                        type: GraphQLEnumType,
                        definition,
                    });
                }
                else if (definition.kind === "ObjectTypeExtension") {
                    const name = getName(definition.name);
                    if (!typeExtensions.GraphQLObjectType[name]) {
                        typeExtensions.GraphQLObjectType[name] = [];
                    }
                    typeExtensions.GraphQLObjectType[name].push(definition);
                }
                else if (definition.kind === "InputObjectTypeExtension") {
                    const name = getName(definition.name);
                    if (!typeExtensions.GraphQLInputObjectType[name]) {
                        typeExtensions.GraphQLInputObjectType[name] = [];
                    }
                    typeExtensions.GraphQLInputObjectType[name].push(definition);
                }
                else if (definition.kind === "InterfaceTypeExtension") {
                    const name = getName(definition.name);
                    if (!typeExtensions.GraphQLInterfaceType[name]) {
                        typeExtensions.GraphQLInterfaceType[name] = [];
                    }
                    typeExtensions.GraphQLInterfaceType[name].push(definition);
                }
                else if (definition.kind === "ObjectTypeDefinition") {
                    newTypes.push({
                        type: GraphQLObjectType,
                        definition,
                    });
                }
                else if (definition.kind === "InputObjectTypeDefinition") {
                    newTypes.push({
                        type: GraphQLInputObjectType,
                        definition,
                    });
                }
                else if (definition.kind === "UnionTypeDefinition") {
                    newTypes.push({
                        type: GraphQLUnionType,
                        definition,
                    });
                }
                else if (definition.kind === "InterfaceTypeDefinition") {
                    newTypes.push({
                        type: GraphQLInterfaceType,
                        definition,
                    });
                }
                else if (definition.kind === "DirectiveDefinition") {
                    newTypes.push({
                        type: GraphQLDirective,
                        definition,
                    });
                }
                else if (definition.kind === "ScalarTypeDefinition") {
                    // TODO: add validation
                    const name = getName(definition.name);
                    if (resolvers[name]) {
                        const gqlScalarType = resolvers[name];
                        if (gqlScalarType.name !== name) {
                            throw new Error(`Names for scalar type do not match; schema: '${name}' vs type: '${String(gqlScalarType.name)}'`);
                        }
                        addType(gqlScalarType);
                    }
                    else {
                        // Create a string type
                        newTypes.push({
                            type: GraphQLScalarType,
                            definition,
                        });
                    }
                }
                else {
                    if (definition.kind === "TypeExtensionDefinition") {
                        throw new Error(`You appear to be using a GraphQL version prior to v0.12.0 which has different syntax for schema extensions (e.g. 'TypeExtensionDefinition' instead of 'ObjectTypeExtension'). Sadly makeExtendSchemaPlugin does not support versions of graphql prior to 0.12.0, please update your version of graphql.`);
                    }
                    throw new Error(`Unexpected '${definition.kind}' definition; we were expecting 'GraphQLEnumType', 'ObjectTypeExtension', 'InputObjectTypeExtension', 'ObjectTypeDefinition' or 'InputObjectTypeDefinition', i.e. something like 'extend type Foo { ... }'`);
                }
            });
            return build.extend(build, {
                [`ExtendSchemaPlugin_${uniqueId}_typeExtensions`]: typeExtensions,
                [`ExtendSchemaPlugin_${uniqueId}_newTypes`]: newTypes,
                [`ExtendSchemaPlugin_${uniqueId}_resolvers`]: resolvers,
            });
        });
        builder.hook("init", (_, build, _context) => {
            const { newWithHooks, [`ExtendSchemaPlugin_${uniqueId}_typeExtensions`]: typeExtensions, // ONLY use this for GraphQLSchema in this hook
            [`ExtendSchemaPlugin_${uniqueId}_newTypes`]: newTypes, [`ExtendSchemaPlugin_${uniqueId}_resolvers`]: resolvers, graphql: { GraphQLEnumType, GraphQLObjectType, GraphQLInputObjectType, GraphQLUnionType, GraphQLInterfaceType, GraphQLScalarType, GraphQLDirective, Kind, }, } = build;
            newTypes.forEach(({ type, definition }) => {
                if (type === GraphQLEnumType) {
                    // https://graphql.org/graphql-js/type/#graphqlenumtype
                    const name = getName(definition.name);
                    const description = getDescription(definition.description);
                    const directives = getDirectives(definition.directives);
                    const relevantResolver = resolvers[name] || {};
                    const values = definition.values.reduce((memo, value) => {
                        const valueName = getName(value.name);
                        const valueDescription = getDescription(value.description);
                        const valueDirectives = getDirectives(value.directives);
                        // Value cannot be expressed via SDL, so we grab the value from the resolvers instead.
                        // resolvers = {
                        //   MyEnum: {
                        //     MY_ENUM_VALUE1: 'value1',
                        //     MY_ENUM_VALUE2: 'value2',
                        //   }
                        // }
                        // Ref: https://github.com/graphql/graphql-js/issues/525#issuecomment-255834625
                        const valueValue = relevantResolver[valueName] !== undefined
                            ? relevantResolver[valueName]
                            : valueName;
                        const valueDeprecationReason = valueDirectives.deprecated && valueDirectives.deprecated.reason;
                        return Object.assign(Object.assign({}, memo), { [valueName]: {
                                value: valueValue,
                                deprecationReason: valueDeprecationReason,
                                description: valueDescription,
                                directives: valueDirectives,
                            } });
                    }, {});
                    const scope = Object.assign({ directives }, (directives.scope || {}));
                    newWithHooks(type, { name, values, description }, scope);
                }
                else if (type === GraphQLObjectType) {
                    // https://graphql.org/graphql-js/type/#graphqlobjecttype
                    const name = getName(definition.name);
                    const description = getDescription(definition.description);
                    const interfaces = getInterfaces(definition.interfaces, build);
                    const directives = getDirectives(definition.directives);
                    const scope = Object.assign({ __origin: `makeExtendSchemaPlugin`, directives }, (directives.scope || {}));
                    newWithHooks(type, Object.assign({ name,
                        interfaces, fields: (fieldsContext) => getFields(fieldsContext.Self, definition.fields, resolvers, fieldsContext, build) }, (description
                        ? {
                            description,
                        }
                        : null)), scope);
                }
                else if (type === GraphQLInputObjectType) {
                    // https://graphql.org/graphql-js/type/#graphqlinputobjecttype
                    const name = getName(definition.name);
                    const description = getDescription(definition.description);
                    const directives = getDirectives(definition.directives);
                    const scope = Object.assign({ __origin: `makeExtendSchemaPlugin`, directives }, (directives.scope || {}));
                    newWithHooks(type, Object.assign({ name, fields: ({ Self }) => getInputFields(Self, definition.fields, build) }, (description
                        ? {
                            description,
                        }
                        : null)), scope);
                }
                else if (type === GraphQLUnionType) {
                    // https://graphql.org/graphql-js/type/#graphqluniontype
                    const name = getName(definition.name);
                    const description = getDescription(definition.description);
                    const directives = getDirectives(definition.directives);
                    const scope = Object.assign({ __origin: `makeExtendSchemaPlugin`, directives }, (directives.scope || {}));
                    const resolveType = resolvers[name] && resolvers[name].__resolveType;
                    newWithHooks(type, Object.assign(Object.assign({ name, types: () => {
                            if (Array.isArray(definition.types)) {
                                return definition.types.map((typeAST) => {
                                    if (typeAST.kind !== "NamedType") {
                                        throw new Error("Only support unions of named types");
                                    }
                                    return getType(typeAST, build);
                                });
                            }
                        } }, (resolveType ? { resolveType } : null)), (description ? { description } : null)), scope);
                }
                else if (type === GraphQLInterfaceType) {
                    // https://graphql.org/graphql-js/type/#graphqluniontype
                    const name = getName(definition.name);
                    const description = getDescription(definition.description);
                    const directives = getDirectives(definition.directives);
                    const scope = Object.assign({ __origin: `makeExtendSchemaPlugin`, directives }, (directives.scope || {}));
                    const resolveType = resolvers[name] && resolvers[name].__resolveType;
                    newWithHooks(type, Object.assign(Object.assign(Object.assign(Object.assign({ name }, (resolveType ? { resolveType } : null)), (description ? { description } : null)), { fields: (fieldsContext) => getFields(fieldsContext.Self, definition.fields, {}, // Interface doesn't need resolvers
                        fieldsContext, build) }), (description
                        ? {
                            description,
                        }
                        : null)), scope);
                }
                else if (type === GraphQLScalarType) {
                    const name = getName(definition.name);
                    const description = getDescription(definition.description);
                    const directives = getDirectives(definition.directives);
                    const scope = Object.assign({ __origin: `makeExtendSchemaPlugin`, directives }, (directives.scope || {}));
                    newWithHooks(type, {
                        name,
                        description,
                        serialize: (value) => String(value),
                        parseValue: (value) => String(value),
                        parseLiteral: (ast) => {
                            if (ast.kind !== Kind.STRING) {
                                throw new Error("Can only parse string values");
                            }
                            return ast.value;
                        },
                    }, scope);
                }
                else if (type === GraphQLDirective) {
                    // https://github.com/graphql/graphql-js/blob/3c54315ab13c6b9d337fb7c33ad7e27b92ca4a40/src/type/directives.js#L106-L113
                    const name = getName(definition.name);
                    const description = getDescription(definition.description);
                    const locations = definition.locations.map(getName);
                    const args = getArguments(definition.arguments, build);
                    // Ignoring isRepeatable and astNode for now
                    const directive = new GraphQLDirective(Object.assign({ name,
                        locations,
                        args }, (description ? { description } : null)));
                    typeExtensions.GraphQLSchema.directives.push(directive);
                }
                else {
                    throw new Error(`We have no code to build an object of type '${type}'; it should not have reached this area of the code.`);
                }
            });
            return _;
        });
        builder.hook("GraphQLSchema", (schema, build, _context) => {
            const { [`ExtendSchemaPlugin_${uniqueId}_typeExtensions`]: typeExtensions, } = build;
            return Object.assign(Object.assign({}, schema), { directives: [
                    ...(schema.directives || build.graphql.specifiedDirectives || []),
                    ...typeExtensions.GraphQLSchema.directives,
                ], types: [...(schema.types || []), ...typeExtensions.GraphQLSchema.types] });
        });
        builder.hook("GraphQLObjectType:fields", (fields, build, context) => {
            const { extend, [`ExtendSchemaPlugin_${uniqueId}_typeExtensions`]: typeExtensions, [`ExtendSchemaPlugin_${uniqueId}_resolvers`]: resolvers, } = build;
            const { Self } = context;
            if (typeExtensions.GraphQLObjectType[Self.name]) {
                const newFields = typeExtensions.GraphQLObjectType[Self.name].reduce((memo, extension) => {
                    const moreFields = getFields(Self, extension.fields, resolvers, context, build);
                    return extend(memo, moreFields);
                }, {});
                return extend(fields, newFields);
            }
            else {
                return fields;
            }
        });
        builder.hook("GraphQLInputObjectType:fields", (fields, build, context) => {
            const { extend, [`ExtendSchemaPlugin_${uniqueId}_typeExtensions`]: typeExtensions, } = build;
            const { Self } = context;
            if (typeExtensions.GraphQLInputObjectType[Self.name]) {
                const newFields = typeExtensions.GraphQLInputObjectType[Self.name].reduce((memo, extension) => {
                    const moreFields = getInputFields(Self, extension.fields, build);
                    return extend(memo, moreFields);
                }, {});
                return extend(fields, newFields);
            }
            else {
                return fields;
            }
        });
        try {
            builder.hook("GraphQLInterfaceType:fields", (fields, build, context) => {
                const { extend, [`ExtendSchemaPlugin_${uniqueId}_typeExtensions`]: typeExtensions, } = build;
                const { Self } = context;
                if (typeExtensions.GraphQLInterfaceType[Self.name]) {
                    const newFields = typeExtensions.GraphQLInterfaceType[Self.name].reduce((memo, extension) => {
                        const moreFields = getFields(Self, extension.fields, {}, // No resolvers for interfaces
                        context, build);
                        return extend(memo, moreFields);
                    }, {});
                    return extend(fields, newFields);
                }
                else {
                    return fields;
                }
            });
        }
        catch (e) {
            console.warn("Please update your version of PostGraphile/Graphile Engine, the version you're using does not support the GraphQLInterfaceType:fields hook");
        }
    };
    function getName(name) {
        if (name && name.kind === "Name" && name.value) {
            return name.value;
        }
        throw new Error("Could not extract name from AST");
    }
    function getDescription(desc) {
        if (!desc) {
            return null;
        }
        else if (desc.kind === "StringValue") {
            return desc.value;
        }
        else {
            throw new Error(`AST issue, we weren't expecting a description of kind '${desc.kind}' - PRs welcome!`);
        }
    }
    function getType(type, build) {
        if (type.kind === "NamedType") {
            const Type = build.getTypeByName(getName(type.name));
            if (!Type) {
                throw new Error(`Could not find type named '${getName(type.name)}'.`);
            }
            return Type;
        }
        else if (type.kind === "NonNullType") {
            return new build.graphql.GraphQLNonNull(getType(type.type, build));
        }
        else if (type.kind === "ListType") {
            return new build.graphql.GraphQLList(getType(type.type, build));
        }
        else {
            throw new Error(`We don't support AST type definition of kind '${type.kind}' yet... PRs welcome!`);
        }
    }
    function getInterfaces(interfaces, build) {
        return interfaces.map(i => build.getTypeByName(i.name.value));
    }
    function getValue(value, inType) {
        const type = inType && graphql.isNonNullType(inType) ? inType.ofType : inType;
        if (value.kind === "BooleanValue") {
            return !!value.value;
        }
        else if (value.kind === "StringValue") {
            return value.value;
        }
        else if (value.kind === "IntValue") {
            return parseInt(value.value, 10);
        }
        else if (value.kind === "FloatValue") {
            return parseFloat(value.value);
        }
        else if (value.kind === "EnumValue") {
            if (!type) {
                throw new Error("We do not support EnumValue arguments in directives at this time");
            }
            const enumValueName = value.value;
            const enumType = graphql.isEnumType(type)
                ? type
                : null;
            if (!enumType) {
                throw new Error(`Tried to interpret an EnumValue for non-enum type ${type}`);
            }
            const values = enumType.getValues();
            const enumValue = values.find(v => v.name === enumValueName);
            return enumValue ? enumValue.value : undefined;
        }
        else if (value.kind === "NullValue") {
            return null;
        }
        else if (value.kind === "ListValue") {
            // This is used in directives, so we cannot assume the type is known.
            const childType = type && graphql.isListType(type) ? type.ofType : null;
            return value.values.map(value => getValue(value, childType));
        }
        else if (value.kind === "GraphileEmbed") {
            // RAW!
            return value.value;
        }
        else {
            throw new Error(`Value kind '${value.kind}' not supported yet. PRs welcome!`);
        }
    }
    function getDirectives(directives) {
        return (directives || []).reduce((directivesList, directive) => {
            if (directive.kind === "Directive") {
                const name = getName(directive.name);
                const value = (directive.arguments || []).reduce((argumentValues, arg) => {
                    if (arg.kind === "Argument") {
                        const argName = getName(arg.name);
                        const argValue = getValue(arg.value);
                        if (argumentValues[name]) {
                            throw new Error(`Argument '${argName}' of directive '${name}' must only be used once.`);
                        }
                        argumentValues[argName] = argValue;
                    }
                    else {
                        throw new Error(`Unexpected '${arg.kind}', we were expecting 'Argument'`);
                    }
                    return argumentValues;
                }, {});
                if (directivesList[name]) {
                    throw new Error(`Directive '${name}' must only be used once per field.`);
                }
                directivesList[name] = value;
            }
            else {
                throw new Error(`Unexpected '${directive.kind}', we were expecting 'Directive'`);
            }
            return directivesList;
        }, {});
    }
    function getArguments(args, build) {
        if (args && args.length) {
            return args.reduce((memo, arg) => {
                if (arg.kind === "InputValueDefinition") {
                    const name = getName(arg.name);
                    const type = getType(arg.type, build);
                    const description = getDescription(arg.description);
                    let defaultValue;
                    if (arg.defaultValue) {
                        defaultValue = getValue(arg.defaultValue, type);
                    }
                    memo[name] = Object.assign(Object.assign({ type }, (defaultValue != null ? { defaultValue } : null)), (description ? { description } : null));
                }
                else {
                    throw new Error(`Unexpected '${arg.kind}', we were expecting an 'InputValueDefinition'`);
                }
                return memo;
            }, {});
        }
        return {};
    }
    function getFields(SelfGeneric, fields, resolvers, { fieldWithHooks, }, build) {
        const scopeByType = build.scopeByType || new Map();
        if (!build.graphql.isNamedType(SelfGeneric)) {
            throw new Error("getFields only supports named types");
        }
        const Self = SelfGeneric;
        const { pgSql: sql, graphql: { isScalarType, getNamedType }, } = build;
        function augmentResolver(resolver, fieldContext, type) {
            let got = false;
            let val;
            const getRecurseDataGeneratorsWorkaroundField = () => {
                if (!got) {
                    got = true;
                    const namedType = build.graphql.getNamedType(type);
                    val = recurseDataGeneratorsWorkaroundFieldByType.get(namedType);
                }
                return val;
            };
            const newResolver = async (parent, args, context, resolveInfo) => {
                const graphileHelpers = (0, fieldHelpers_1.makeFieldHelpers)(build, fieldContext, context, resolveInfo);
                const result = await resolver(parent, args, context, Object.assign(Object.assign({}, resolveInfo), { graphile: graphileHelpers }), graphileHelpers);
                const recurseDataGeneratorsWorkaroundField = getRecurseDataGeneratorsWorkaroundField();
                if (result != null &&
                    !result.data &&
                    recurseDataGeneratorsWorkaroundField) {
                    return Object.assign(Object.assign({}, result), { data: result[recurseDataGeneratorsWorkaroundField] });
                }
                return result;
            };
            return newResolver;
        }
        if (fields && fields.length) {
            return fields.reduce((memo, field) => {
                if (field.kind === "FieldDefinition") {
                    const description = getDescription(field.description);
                    const fieldName = getName(field.name);
                    const args = getArguments(field.arguments, build);
                    const type = getType(field.type, build);
                    const nullableType = build.graphql.getNullableType(type);
                    const namedType = build.graphql.getNamedType(type);
                    const typeScope = scopeByType.get(namedType) || {};
                    const directives = getDirectives(field.directives);
                    const scope = Object.assign(Object.assign(Object.assign(Object.assign({}, (typeScope.pgIntrospection &&
                        typeScope.pgIntrospection.kind === "class"
                        ? {
                            pgFieldIntrospection: typeScope.pgIntrospection,
                        }
                        : null)), (typeScope.isPgRowConnectionType && typeScope.pgIntrospection
                        ? {
                            isPgFieldConnection: true,
                            pgFieldIntrospection: typeScope.pgIntrospection,
                        }
                        : null)), { fieldDirectives: directives }), (directives.scope || {}));
                    const deprecationReason = directives.deprecated && directives.deprecated.reason;
                    const functionToResolveObject = (functionOrResolveObject) => typeof functionOrResolveObject === "function"
                        ? { resolve: functionOrResolveObject }
                        : functionOrResolveObject;
                    const isConnection = !!scope.isPgFieldConnection;
                    const isListType = nullableType !== namedType &&
                        nullableType.constructor === build.graphql.GraphQLList;
                    const table = scope.pgFieldIntrospection &&
                        scope.pgFieldIntrospection.kind === "class"
                        ? scope.pgFieldIntrospection
                        : null;
                    const isScalar = isScalarType(getNamedType(type));
                    const generateImplicitResolverIfPossible = () => {
                        if (directives.pgQuery &&
                            ((table && directives.pgQuery.source) ||
                                (isScalar && directives.pgQuery.fragment))) {
                            return (data, _args, _resolveContext, resolveInfo) => {
                                const safeAlias = build.getSafeAliasFromResolveInfo(resolveInfo);
                                const liveRecord = resolveInfo.rootValue && resolveInfo.rootValue.liveRecord;
                                if (isConnection) {
                                    return build.pgAddStartEndCursor(data[safeAlias]);
                                }
                                else if (isListType) {
                                    const records = data[safeAlias];
                                    if (table && liveRecord) {
                                        records.forEach((r) => r && liveRecord("pg", table, r.__identifiers));
                                    }
                                    return records;
                                }
                                else {
                                    const record = data[safeAlias];
                                    if (record && liveRecord && table) {
                                        liveRecord("pg", table, record.__identifiers);
                                    }
                                    return record;
                                }
                            };
                        }
                        return null;
                    };
                    /*
                     * We accept a resolver function directly, or an object which can
                     * define 'resolve', 'subscribe' and other relevant methods.
                     */
                    const possibleResolver = resolvers[Self.name]
                        ? resolvers[Self.name][fieldName]
                        : null;
                    const resolver = possibleResolver &&
                        (typeof possibleResolver === "object" ||
                            typeof possibleResolver === "function")
                        ? possibleResolver
                        : generateImplicitResolverIfPossible();
                    const rawResolversSpec = resolver
                        ? functionToResolveObject(resolver)
                        : null;
                    if (directives.recurseDataGenerators) {
                        if (!recurseDataGeneratorsWorkaroundFieldByType.get(Self)) {
                            recurseDataGeneratorsWorkaroundFieldByType.set(Self, fieldName);
                        }
                        // eslint-disable-next-line no-console
                        console.warn("DEPRECATION: `recurseDataGenerators` is misleading, please use `pgField` instead");
                        if (!directives.pgField) {
                            directives.pgField = directives.recurseDataGenerators;
                        }
                    }
                    const fieldSpecGenerator = (fieldContext) => {
                        const { pgIntrospection } = fieldContext.scope;
                        // @requires directive: pulls down necessary columns from table.
                        //
                        //   e.g. `@requires(columns: ["id", "name"])`
                        //
                        if (directives.requires && pgIntrospection.kind === "class") {
                            const table = pgIntrospection;
                            if (Array.isArray(directives.requires.columns)) {
                                const attrs = table.attributes.filter(attr => directives.requires.columns.indexOf(attr.name) >= 0);
                                const fieldNames = attrs.map(attr => build.inflection.column(attr));
                                const ReturnTypes = attrs.map(attr => build.pgGetGqlTypeByTypeIdAndModifier(attr.typeId, attr.typeModifier) || build.graphql.GraphQLString);
                                fieldContext.addDataGenerator((parsedResolveInfoFragment) => ({
                                    pgQuery: (queryBuilder) => {
                                        attrs.forEach((attr, i) => {
                                            const columnFieldName = fieldNames[i];
                                            const ReturnType = ReturnTypes[i];
                                            queryBuilder.select(build.pgGetSelectValueForFieldAndTypeAndModifier(ReturnType, fieldContext, parsedResolveInfoFragment, sql.fragment `(${queryBuilder.getTableAlias()}.${sql.identifier(attr.name)})`, // The brackets are necessary to stop the parser getting confused, ref: https://www.postgresql.org/docs/9.6/static/rowtypes.html#ROWTYPES-ACCESSING
                                            attr.type, attr.typeModifier), columnFieldName);
                                        });
                                    },
                                }));
                            }
                            else {
                                throw new Error(`@requires(columns: ["...", ...]) directive called with invalid arguments`);
                            }
                        }
                        if (directives.pgQuery) {
                            if (table && directives.pgQuery.source) {
                                fieldContext.addDataGenerator((parsedResolveInfoFragment) => {
                                    return {
                                        pgQuery: (queryBuilder) => {
                                            const source = typeof directives.pgQuery.source === "function"
                                                ? directives.pgQuery.source(queryBuilder, parsedResolveInfoFragment.args)
                                                : directives.pgQuery.source;
                                            queryBuilder.select(() => {
                                                const resolveData = fieldContext.getDataFromParsedResolveInfoFragment(parsedResolveInfoFragment, namedType);
                                                const tableAlias = sql.identifier(Symbol());
                                                const query = build.pgQueryFromResolveData(source, tableAlias, resolveData, {
                                                    withPagination: isConnection,
                                                    withPaginationAsFields: false,
                                                    asJsonAggregate: isListType && !isConnection,
                                                    asJson: !isConnection,
                                                    addNullCase: !isConnection,
                                                }, (innerQueryBuilder) => {
                                                    innerQueryBuilder.parentQueryBuilder =
                                                        queryBuilder;
                                                    if (build.options.subscriptions &&
                                                        table.primaryKeyConstraint) {
                                                        innerQueryBuilder.selectIdentifiers(table);
                                                    }
                                                    if (typeof directives.pgQuery.withQueryBuilder ===
                                                        "function") {
                                                        directives.pgQuery.withQueryBuilder(innerQueryBuilder, parsedResolveInfoFragment.args);
                                                    }
                                                }, queryBuilder.context, queryBuilder.rootValue);
                                                return sql.fragment `(${query})`;
                                            }, build.getSafeAliasFromAlias(parsedResolveInfoFragment.alias));
                                        },
                                    };
                                });
                            }
                            else if (isScalar && directives.pgQuery.fragment) {
                                fieldContext.addDataGenerator((parsedResolveInfoFragment) => {
                                    return {
                                        pgQuery: (queryBuilder) => {
                                            queryBuilder.select(typeof directives.pgQuery.fragment === "function"
                                                ? directives.pgQuery.fragment(queryBuilder, parsedResolveInfoFragment.args)
                                                : directives.pgQuery.fragment, build.getSafeAliasFromAlias(parsedResolveInfoFragment.alias));
                                        },
                                    };
                                });
                            }
                            else {
                                throw new Error(`@pgQuery(...) directive called with invalid arguments - for a table value, call it with 'source' for a scalar with 'fragment'!`);
                            }
                        }
                        const resolversSpec = rawResolversSpec
                            ? Object.keys(rawResolversSpec).reduce((newResolversSpec, key) => {
                                if (typeof rawResolversSpec[key] === "function") {
                                    newResolversSpec[key] = augmentResolver(rawResolversSpec[key], fieldContext, type);
                                }
                                return newResolversSpec;
                            }, {})
                            : {};
                        return Object.assign(Object.assign(Object.assign({ type,
                            args }, (deprecationReason
                            ? {
                                deprecationReason,
                            }
                            : null)), (description
                            ? {
                                description,
                            }
                            : null)), resolversSpec);
                    };
                    if (directives.pgField) {
                        return build.extend(memo, {
                            [fieldName]: build.pgField(build, fieldWithHooks, fieldName, fieldSpecGenerator, scope, false),
                        });
                    }
                    else {
                        return build.extend(memo, {
                            [fieldName]: fieldWithHooks(fieldName, fieldSpecGenerator, scope),
                        });
                    }
                }
                else {
                    throw new Error(`AST issue: expected 'FieldDefinition', instead received '${field.kind}'`);
                }
            }, {});
        }
        return {};
    }
    function getInputFields(_Self, fields, build) {
        if (fields && fields.length) {
            return fields.reduce((memo, field) => {
                if (field.kind === "InputValueDefinition") {
                    const description = getDescription(field.description);
                    const fieldName = getName(field.name);
                    const type = getType(field.type, build);
                    const defaultValue = field.defaultValue
                        ? getValue(field.defaultValue, type)
                        : undefined;
                    memo[fieldName] = Object.assign({ type,
                        defaultValue }, (description
                        ? {
                            description,
                        }
                        : null));
                }
                else {
                    throw new Error(`AST issue: expected 'FieldDefinition', instead received '${field.kind}'`);
                }
                return memo;
            }, {});
        }
        return {};
    }
}
exports.default = makeExtendSchemaPlugin;
//# sourceMappingURL=makeExtendSchemaPlugin.js.map