{"version":3,"sources":["../../src/plugins/makeProcField.js"],"names":["nullableIf","GraphQLNonNull","condition","Type","firstValue","obj","firstKey","k","procFieldDetails","proc","build","options","computed","isMutation","pgIntrospectionResultsByKind","introspectionResultsByKind","pgGetGqlInputTypeByTypeIdAndModifier","pgSql","sql","gql2pg","pgStrictFunctions","strictFunctions","graphql","inflection","describePgEntity","sqlCommentByAddingTags","Error","sliceAmount","argNames","argTypeIds","reduce","prev","_","idx","argModes","length","push","argTypes","typeId","typeById","argModesWithOutput","outputArgNames","includes","outputArgTypes","requiredArgCount","Math","max","argDefaultsNum","variantFromName","name","match","variantFromTags","tags","variant","parseInt","notNullArgCount","isStrict","argGqlTypes","map","type","id","hint","class","chalk","bold","green","inputs","memo","argName","argIndex","gqlArgName","argument","makeSqlFunctionCall","rawArgs","implicitArgs","unnest","args","input","sqlArgValues","haveNames","value","sqlValue","sqlArgName","identifier","unshift","fragment","functionCall","namespace","join","makeProcField","fieldName","fieldWithHooks","isRootQuery","forceList","aggregateWrapper","description","overrideDescription","pgTypeAndModifierModifier","pgGetGqlTypeByTypeIdAndModifier","getTypeByName","parseResolveInfo","getSafeAliasFromResolveInfo","getSafeAliasFromAlias","pg2gql","newWithHooks","pgTweakFragmentForTypeAndModifier","GraphQLList","GraphQLString","GraphQLObjectType","GraphQLInputObjectType","getNamedType","isCompositeType","pgQueryFromResolveData","queryFromResolveData","pgAddStartEndCursor","addStartEndCursor","pgViaTemporaryTable","viaTemporaryTable","pgField","subscriptions","pgForbidSetofFunctionsToReturnNull","pgPrepareAndRun","baseReturnType","returnTypeId","rawReturnType","returnType","isPgArray","arrayItemType","returnTypeTable","classById","classId","fieldScope","payloadTypeScope","pgFieldIntrospection","pgIntrospection","returnFirstValueAsValue","TableType","isTableLike","isRecordLike","returnsSet","innerType","isPgFieldSimpleCollection","ConnectionType","connection","isPgFieldConnection","pgFieldIntrospectionTable","pgIntrospectionTable","RecordType","recordFunctionReturnType","recordFunctionConnection","connectionTypeName","scalarFunctionConnection","addDataGenerator","getDataFromParsedResolveInfoFragment","addArgDataGenerator","addPgCursorPrefix","pgCursorPrefix","literal","makeQuery","parsedResolveInfoFragment","ReturnType","sqlMutationQuery","functionAlias","parentQueryBuilder","resolveContext","resolveInfo","resolveData","isConnection","query","useAsterisk","language","withPagination","withPaginationAsFields","asJson","asJsonAggregate","addNullCase","innerQueryBuilder","select","primaryKeyConstraint","selectIdentifiers","context","rootValue","pgQuery","queryBuilder","parentTableAlias","getTableAlias","Symbol","sqlFunctionCall","alias","PayloadType","resultFieldName","functionMutationResultFieldName","isNotVoid","String","functionPayloadType","wrapDescription","functionMutationName","fields","Object","assign","clientMutationId","resolve","data","pgType","__origin","isMutationPayload","InputType","functionInputType","isMutationInput","scalarAwarePg2gql","v","notNull","_args","liveRecord","safeAlias","makeRecordLive","record","__identifiers","_record","records","pgClient","queryResultRows","intermediateIdentifier","isVoid","isPgRecord","isPgClass","namespaceName","e","text","values","compile","debugSql","enabled","queryResult","rows","row","result","fv"],"mappings":"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","sourcesContent":["// @flow\nconst nullableIf = (GraphQLNonNull, condition, Type) =>\n  condition ? Type : new GraphQLNonNull(Type);\n\nimport type { Build, FieldWithHooksFunction } from \"graphile-build\";\nimport type { PgProc, PgType } from \"./PgIntrospectionPlugin\";\nimport type { SQL } from \"pg-sql2\";\nimport debugSql from \"./debugSql\";\nimport chalk from \"chalk\";\n\ntype ProcFieldOptions = {\n  fieldWithHooks: FieldWithHooksFunction,\n  computed?: boolean,\n  isMutation?: boolean,\n  isRootQuery?: boolean,\n  forceList?: boolean,\n  aggregateWrapper?: null | ((sql: SQL) => SQL),\n  description?: string,\n  pgTypeAndModifierModifier?:\n    | null\n    | ((\n        pgType: PgType,\n        pgTypeModifier: null | string | number\n      ) => [PgType, null | string | number]),\n};\n\nconst firstValue = obj => {\n  let firstKey;\n  for (const k in obj) {\n    if (k[0] !== \"_\" && k[1] !== \"_\") {\n      firstKey = k;\n    }\n  }\n  return obj[firstKey];\n};\n\nexport function procFieldDetails(\n  proc: PgProc,\n  build: {| ...Build |},\n  options: {\n    computed?: boolean,\n    isMutation?: boolean,\n  }\n) {\n  const { computed = false, isMutation = false } = options;\n  const {\n    pgIntrospectionResultsByKind: introspectionResultsByKind,\n    pgGetGqlInputTypeByTypeIdAndModifier,\n    pgSql: sql,\n    gql2pg,\n    pgStrictFunctions: strictFunctions,\n    graphql: { GraphQLNonNull },\n    inflection,\n    describePgEntity,\n    sqlCommentByAddingTags,\n  } = build;\n\n  if (computed && isMutation) {\n    throw new Error(\"Mutation procedure cannot be computed\");\n  }\n\n  const sliceAmount = computed ? 1 : 0;\n  const argNames = proc.argTypeIds.reduce((prev, _, idx) => {\n    if (\n      idx >= sliceAmount && // Was a .slice() call\n      (proc.argModes.length === 0 || // all args are `in`\n        proc.argModes[idx] === \"i\" || // this arg is `in`\n        proc.argModes[idx] === \"b\") // this arg is `inout`\n    ) {\n      prev.push(proc.argNames[idx] || \"\");\n    }\n    return prev;\n  }, []);\n  const argTypes = proc.argTypeIds.reduce((prev, typeId, idx) => {\n    if (\n      idx >= sliceAmount && // Was a .slice() call\n      (proc.argModes.length === 0 || // all args are `in`\n        proc.argModes[idx] === \"i\" || // this arg is `in`\n        proc.argModes[idx] === \"b\") // this arg is `inout`\n    ) {\n      prev.push(introspectionResultsByKind.typeById[typeId]);\n    }\n    return prev;\n  }, []);\n  const argModesWithOutput = [\n    \"o\", // OUT,\n    \"b\", // INOUT\n    \"t\", // TABLE\n  ];\n  const outputArgNames = proc.argTypeIds.reduce((prev, _, idx) => {\n    if (argModesWithOutput.includes(proc.argModes[idx])) {\n      prev.push(proc.argNames[idx] || \"\");\n    }\n    return prev;\n  }, []);\n  const outputArgTypes = proc.argTypeIds.reduce((prev, typeId, idx) => {\n    if (argModesWithOutput.includes(proc.argModes[idx])) {\n      prev.push(introspectionResultsByKind.typeById[typeId]);\n    }\n    return prev;\n  }, []);\n  const requiredArgCount = Math.max(0, argNames.length - proc.argDefaultsNum);\n  const variantFromName = name => {\n    if (name.match(/(_p|P)atch$/)) {\n      return \"patch\";\n    }\n    return null;\n  };\n  const variantFromTags = (tags, idx) => {\n    const variant = tags[`arg${idx}variant`];\n    if (variant && variant.match && variant.match(/^[0-9]+$/)) {\n      return parseInt(variant, 10);\n    }\n    return variant;\n  };\n  const notNullArgCount =\n    proc.isStrict || strictFunctions ? requiredArgCount : 0;\n  const argGqlTypes = argTypes.map((type, idx) => {\n    // TODO: PG10 doesn't support the equivalent of pg_attribute.atttypemod on function return values, but maybe a later version might\n    const variant =\n      variantFromTags(proc.tags, idx) || variantFromName(argNames[idx]);\n    const Type = pgGetGqlInputTypeByTypeIdAndModifier(type.id, variant);\n    if (!Type) {\n      const hint = type.class\n        ? `; this might be because no INSERT column privileges are granted on ${describePgEntity(\n            type.class\n          )}. You can use 'Smart Comments' to tell PostGraphile to instead use the \"${chalk.bold.green(\n            \"base\"\n          )}\" input type which includes all columns:\\n\\n  ${sqlCommentByAddingTags(\n            proc,\n            {\n              [`arg${idx}variant`]: \"base\",\n            }\n          )}\\n`\n        : \"\";\n      throw new Error(\n        `Could not determine type for argument ${idx} ('${\n          argNames[idx]\n        }') of function ${describePgEntity(proc)}${hint}`\n      );\n    }\n    if (idx >= notNullArgCount) {\n      return Type;\n    } else {\n      return new GraphQLNonNull(Type);\n    }\n  });\n  // This wants to be compatible with both being field arguments and being\n  // input object fields (e.g. for the aggregates plugin).\n  const inputs = argNames.reduce((memo, argName, argIndex) => {\n    const gqlArgName = inflection.argument(argName, argIndex);\n    memo[gqlArgName] = {\n      type: argGqlTypes[argIndex],\n    };\n    return memo;\n  }, {});\n\n  function makeSqlFunctionCall(\n    rawArgs = {},\n    { implicitArgs = [], unnest = false } = {}\n  ): SQL {\n    const args = isMutation ? rawArgs.input : rawArgs;\n    const sqlArgValues = [];\n    let haveNames = true;\n    for (let argIndex = argNames.length - 1; argIndex >= 0; argIndex--) {\n      const argName = argNames[argIndex];\n      const gqlArgName = inflection.argument(argName, argIndex);\n      const value = args[gqlArgName];\n      const variant =\n        variantFromTags(proc.tags, argIndex) ||\n        variantFromName(argNames[argIndex]);\n\n      const sqlValue = gql2pg(value, argTypes[argIndex], variant);\n\n      if (argIndex + 1 > requiredArgCount && haveNames && value == null) {\n        // No need to pass argument to function\n        continue;\n      } else if (argIndex + 1 > requiredArgCount && haveNames) {\n        const sqlArgName = argName ? sql.identifier(argName) : null;\n        if (sqlArgName) {\n          sqlArgValues.unshift(sql.fragment`${sqlArgName} := ${sqlValue}`);\n        } else {\n          haveNames = false;\n          sqlArgValues.unshift(sqlValue);\n        }\n      } else {\n        sqlArgValues.unshift(sqlValue);\n      }\n    }\n    const functionCall = sql.fragment`${sql.identifier(\n      proc.namespace.name,\n      proc.name\n    )}(${sql.join([...implicitArgs, ...sqlArgValues], \", \")})`;\n    return unnest ? sql.fragment`unnest(${functionCall})` : functionCall;\n  }\n\n  return {\n    inputs,\n    makeSqlFunctionCall,\n    outputArgNames,\n    outputArgTypes,\n  };\n}\n\nexport default function makeProcField(\n  fieldName: string,\n  proc: PgProc,\n  build: {| ...Build |},\n  options: ProcFieldOptions\n) {\n  const {\n    fieldWithHooks,\n    computed = false,\n    isMutation = false,\n    isRootQuery = false,\n    forceList = false,\n    aggregateWrapper = null,\n    description: overrideDescription = null,\n    pgTypeAndModifierModifier = null,\n  } = options;\n  const {\n    pgIntrospectionResultsByKind: introspectionResultsByKind,\n    pgGetGqlTypeByTypeIdAndModifier,\n    getTypeByName,\n    pgSql: sql,\n    parseResolveInfo,\n    getSafeAliasFromResolveInfo,\n    getSafeAliasFromAlias,\n    pg2gql,\n    newWithHooks,\n    pgTweakFragmentForTypeAndModifier,\n    graphql: {\n      GraphQLNonNull,\n      GraphQLList,\n      GraphQLString,\n      GraphQLObjectType,\n      GraphQLInputObjectType,\n      getNamedType,\n      isCompositeType,\n    },\n    inflection,\n    pgQueryFromResolveData: queryFromResolveData,\n    pgAddStartEndCursor: addStartEndCursor,\n    pgViaTemporaryTable: viaTemporaryTable,\n    describePgEntity,\n    sqlCommentByAddingTags,\n    pgField,\n    options: {\n      subscriptions = false,\n      pgForbidSetofFunctionsToReturnNull = false,\n    },\n    pgPrepareAndRun,\n  } = build;\n\n  const { inputs, makeSqlFunctionCall, outputArgNames, outputArgTypes } =\n    procFieldDetails(proc, build, options);\n  let args = inputs;\n\n  /**\n   * This is the return type the function claims to have; we\n   * should not use it anywhere but these next few lines.\n   */\n  const baseReturnType = introspectionResultsByKind.typeById[proc.returnTypeId];\n\n  /**\n   * This is the return type we treat it as having, e.g. in\n   * case it was modified by wrapping it in an aggregate or\n   * similar.\n   */\n  const rawReturnType = pgTypeAndModifierModifier\n    ? pgTypeAndModifierModifier(baseReturnType, null)[0]\n    : baseReturnType;\n\n  /**\n   * This is the type without the array wrapper.\n   */\n  const returnType = rawReturnType.isPgArray\n    ? rawReturnType.arrayItemType\n    : rawReturnType;\n  const returnTypeTable =\n    introspectionResultsByKind.classById[returnType.classId];\n  if (!returnType) {\n    throw new Error(\n      `Could not determine return type for function '${proc.name}'`\n    );\n  }\n  let type;\n  const fieldScope = {};\n  const payloadTypeScope = {};\n  fieldScope.pgFieldIntrospection = proc;\n  payloadTypeScope.pgIntrospection = proc;\n  let returnFirstValueAsValue = false;\n  const TableType =\n    returnTypeTable &&\n    pgGetGqlTypeByTypeIdAndModifier(returnTypeTable.type.id, null);\n\n  const isTableLike: boolean =\n    (TableType && isCompositeType(TableType)) || false;\n  const isRecordLike = returnType.id === \"2249\";\n  if (isTableLike) {\n    if (proc.returnsSet) {\n      if (isMutation) {\n        const innerType = pgForbidSetofFunctionsToReturnNull\n          ? new GraphQLNonNull(TableType)\n          : TableType;\n        type = new GraphQLList(innerType);\n      } else if (forceList) {\n        const innerType = pgForbidSetofFunctionsToReturnNull\n          ? new GraphQLNonNull(TableType)\n          : TableType;\n        type = new GraphQLList(innerType);\n        fieldScope.isPgFieldSimpleCollection = true;\n      } else {\n        const ConnectionType = getTypeByName(\n          inflection.connection(TableType.name)\n        );\n        if (!ConnectionType) {\n          throw new Error(\n            `Do not have a connection type '${inflection.connection(\n              TableType.name\n            )}' for '${TableType.name}' so cannot create procedure field`\n          );\n        }\n        type = ConnectionType;\n        fieldScope.isPgFieldConnection = true;\n      }\n      fieldScope.pgFieldIntrospectionTable = returnTypeTable;\n      payloadTypeScope.pgIntrospectionTable = returnTypeTable;\n    } else {\n      type = TableType;\n      if (rawReturnType.isPgArray) {\n        // Not implementing pgForbidSetofFunctionsToReturnNull here because it's not a set\n        type = new GraphQLList(type);\n      }\n      fieldScope.pgFieldIntrospectionTable = returnTypeTable;\n      payloadTypeScope.pgIntrospectionTable = returnTypeTable;\n    }\n  } else if (isRecordLike) {\n    const RecordType = getTypeByName(inflection.recordFunctionReturnType(proc));\n    if (!RecordType) {\n      throw new Error(\n        `Do not have a record type '${inflection.recordFunctionReturnType(\n          proc\n        )}' for '${proc.name}' so cannot create procedure field`\n      );\n    }\n    if (proc.returnsSet) {\n      if (isMutation) {\n        type = new GraphQLList(RecordType);\n      } else if (forceList) {\n        type = new GraphQLList(RecordType);\n        fieldScope.isPgFieldSimpleCollection = true;\n      } else {\n        const ConnectionType = getTypeByName(\n          inflection.recordFunctionConnection(proc)\n        );\n        if (!ConnectionType) {\n          throw new Error(\n            `Do not have a connection type '${inflection.recordFunctionConnection(\n              proc\n            )}' for '${RecordType.name}' so cannot create procedure field`\n          );\n        }\n        type = ConnectionType;\n        fieldScope.isPgFieldConnection = true;\n      }\n    } else {\n      type = RecordType;\n      if (rawReturnType.isPgArray) {\n        type = new GraphQLList(type);\n      }\n    }\n  } else {\n    // TODO: PG10 doesn't support the equivalent of pg_attribute.atttypemod on function return values, but maybe a later version might\n    const Type =\n      pgGetGqlTypeByTypeIdAndModifier(returnType.id, null) || GraphQLString;\n\n    if (proc.returnsSet) {\n      const connectionTypeName = inflection.scalarFunctionConnection(proc);\n      const ConnectionType = getTypeByName(connectionTypeName);\n      if (isMutation) {\n        // Cannot return a connection because it would have to run the mutation again\n        type = new GraphQLList(Type);\n        returnFirstValueAsValue = true;\n      } else if (forceList || !ConnectionType) {\n        type = new GraphQLList(Type);\n        returnFirstValueAsValue = true;\n        fieldScope.isPgFieldSimpleCollection = true;\n      } else {\n        type = ConnectionType;\n        fieldScope.isPgFieldConnection = true;\n        // We don't return the first value as the value here because it gets\n        // sent down into PgScalarFunctionConnectionPlugin so the relevant\n        // EdgeType can return cursor / node; i.e. we might want to add an\n        // `__cursor` field so we can't just use a scalar.\n      }\n    } else {\n      returnFirstValueAsValue = true;\n      type = Type;\n      if (rawReturnType.isPgArray) {\n        type = new GraphQLList(type);\n      }\n    }\n  }\n  return fieldWithHooks(\n    fieldName,\n    ({\n      addDataGenerator,\n      getDataFromParsedResolveInfoFragment,\n      addArgDataGenerator,\n    }) => {\n      if (\n        proc.returnsSet &&\n        !isTableLike &&\n        !returnFirstValueAsValue &&\n        !isMutation\n      ) {\n        // Natural ordering\n        addArgDataGenerator(function addPgCursorPrefix() {\n          return {\n            pgCursorPrefix: sql.literal(\"natural\"),\n          };\n        });\n      }\n      function makeQuery(\n        parsedResolveInfoFragment,\n        ReturnType,\n        sqlMutationQuery,\n        functionAlias,\n        parentQueryBuilder,\n        resolveContext,\n        resolveInfo\n      ) {\n        const resolveData = getDataFromParsedResolveInfoFragment(\n          parsedResolveInfoFragment,\n          ReturnType\n        );\n        const isConnection = !forceList && !isMutation && proc.returnsSet;\n        const query = queryFromResolveData(\n          sqlMutationQuery,\n          functionAlias,\n          resolveData,\n          {\n            useAsterisk:\n              !isMutation &&\n              (isTableLike || isRecordLike) &&\n              (forceList || proc.returnsSet || rawReturnType.isPgArray) && // only bother with lists\n              proc.language !== \"sql\", // sql functions can be inlined, so GRANTs still apply\n            withPagination: isConnection,\n            withPaginationAsFields: isConnection && !computed,\n            asJson:\n              computed &&\n              (forceList || (!proc.returnsSet && !returnFirstValueAsValue)),\n            asJsonAggregate:\n              computed &&\n              (forceList || (!proc.returnsSet && rawReturnType.isPgArray)),\n            addNullCase:\n              !proc.returnsSet &&\n              !rawReturnType.isPgArray &&\n              (isTableLike || isRecordLike),\n          },\n          innerQueryBuilder => {\n            innerQueryBuilder.parentQueryBuilder = parentQueryBuilder;\n            if (!isTableLike) {\n              if (returnTypeTable) {\n                innerQueryBuilder.select(\n                  pgTweakFragmentForTypeAndModifier(\n                    sql.fragment`${functionAlias}`,\n                    returnTypeTable.type,\n                    null,\n                    resolveData\n                  ),\n                  \"value\"\n                );\n              } else {\n                innerQueryBuilder.select(\n                  pgTweakFragmentForTypeAndModifier(\n                    sql.fragment`${functionAlias}`,\n                    returnType,\n                    null, // We can't determine a type modifier for functions\n                    resolveData\n                  ),\n                  \"value\"\n                );\n              }\n            } else if (\n              subscriptions &&\n              returnTypeTable &&\n              !isConnection &&\n              returnTypeTable.primaryKeyConstraint\n            ) {\n              innerQueryBuilder.selectIdentifiers(returnTypeTable);\n            }\n          },\n          parentQueryBuilder ? parentQueryBuilder.context : resolveContext,\n          parentQueryBuilder\n            ? parentQueryBuilder.rootValue\n            : resolveInfo && resolveInfo.rootValue\n        );\n        return query;\n      }\n      if (computed) {\n        addDataGenerator((parsedResolveInfoFragment, ReturnType) => {\n          return {\n            pgQuery: queryBuilder => {\n              queryBuilder.select(() => {\n                const parentTableAlias = queryBuilder.getTableAlias();\n                const functionAlias = sql.identifier(Symbol());\n                const sqlFunctionCall = makeSqlFunctionCall(\n                  parsedResolveInfoFragment.args,\n                  {\n                    implicitArgs: [parentTableAlias],\n                    unnest: rawReturnType.isPgArray,\n                  }\n                );\n                if (aggregateWrapper) {\n                  return aggregateWrapper(sqlFunctionCall);\n                } else {\n                  const query = makeQuery(\n                    parsedResolveInfoFragment,\n                    ReturnType,\n                    sqlFunctionCall,\n                    functionAlias,\n                    queryBuilder\n                  );\n                  return sql.fragment`(${query})`;\n                }\n              }, getSafeAliasFromAlias(parsedResolveInfoFragment.alias));\n            },\n          };\n        });\n      }\n\n      let ReturnType = type;\n      let PayloadType;\n      if (isMutation) {\n        const resultFieldName = inflection.functionMutationResultFieldName(\n          proc,\n          getNamedType(type),\n          proc.returnsSet || rawReturnType.isPgArray,\n          outputArgNames\n        );\n        const isNotVoid = String(returnType.id) !== \"2278\";\n        // If set then plural name\n        PayloadType = newWithHooks(\n          GraphQLObjectType,\n          {\n            name: inflection.functionPayloadType(proc),\n            description: build.wrapDescription(\n              `The output of our \\`${inflection.functionMutationName(\n                proc\n              )}\\` mutation.`,\n              \"type\"\n            ),\n            fields: ({ fieldWithHooks }) => {\n              return Object.assign(\n                {},\n                {\n                  clientMutationId: {\n                    type: GraphQLString,\n                  },\n                },\n                isNotVoid\n                  ? {\n                      [resultFieldName]: pgField(\n                        build,\n                        fieldWithHooks,\n                        resultFieldName,\n                        {\n                          type: type,\n                          ...(returnFirstValueAsValue\n                            ? {\n                                resolve(data) {\n                                  return data.data;\n                                },\n                              }\n                            : null),\n                        },\n                        {},\n                        false,\n                        {\n                          pgType: returnType,\n                        }\n                      ),\n                      // Result\n                    }\n                  : null\n              );\n            },\n          },\n          {\n            __origin: `Adding mutation function payload type for ${describePgEntity(\n              proc\n            )}. You can rename the function's GraphQL field (and its dependent types) via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            isMutationPayload: true,\n            ...payloadTypeScope,\n          }\n        );\n        ReturnType = PayloadType;\n        const InputType = newWithHooks(\n          GraphQLInputObjectType,\n          {\n            name: inflection.functionInputType(proc),\n            description: build.wrapDescription(\n              `All input for the \\`${inflection.functionMutationName(\n                proc\n              )}\\` mutation.`,\n              \"type\"\n            ),\n            fields: {\n              clientMutationId: {\n                type: GraphQLString,\n              },\n              ...args,\n            },\n          },\n          {\n            __origin: `Adding mutation function input type for ${describePgEntity(\n              proc\n            )}. You can rename the function's GraphQL field (and its dependent types) via a 'Smart Comment':\\n\\n  ${sqlCommentByAddingTags(\n              proc,\n              {\n                name: \"newNameHere\",\n              }\n            )}`,\n            isMutationInput: true,\n          }\n        );\n        args = {\n          input: {\n            type: new GraphQLNonNull(InputType),\n          },\n        };\n      }\n      // If this is a table we can process it directly; but if it's a scalar\n      // setof function we must dereference '.value' from it, because this\n      // makes space for '__cursor' to exist alongside it (whereas on a table\n      // the '__cursor' can just be on the table object itself)\n      const scalarAwarePg2gql = v =>\n        isTableLike\n          ? pg2gql(v, returnType)\n          : {\n              ...v,\n              value: pg2gql(v.value, returnType),\n            };\n\n      return {\n        description: overrideDescription\n          ? overrideDescription\n          : proc.description\n          ? proc.description\n          : isMutation\n          ? null\n          : isTableLike && proc.returnsSet\n          ? build.wrapDescription(\n              `Reads and enables pagination through a set of \\`${TableType.name}\\`.`,\n              \"field\"\n            )\n          : null,\n        type: nullableIf(\n          GraphQLNonNull,\n          !proc.tags.notNull &&\n            (!fieldScope.isPgFieldConnection || isMutation || isRootQuery),\n          ReturnType\n        ),\n        args: args,\n        resolve: computed\n          ? (data, _args, resolveContext, resolveInfo) => {\n              const liveRecord =\n                resolveInfo.rootValue && resolveInfo.rootValue.liveRecord;\n              const safeAlias = getSafeAliasFromResolveInfo(resolveInfo);\n              const value = data[safeAlias];\n              if (returnFirstValueAsValue) {\n                // Is not table like; is not record like.\n                if (proc.returnsSet && !forceList) {\n                  // EITHER `isMutation` is true, or `ConnectionType` does not\n                  // exist - either way, we're not returning a connection.\n                  return value.data.map(v => pg2gql(firstValue(v), returnType));\n                } else if (proc.returnsSet || rawReturnType.isPgArray) {\n                  return value.map(v => pg2gql(firstValue(v), returnType));\n                } else {\n                  return pg2gql(value, returnType);\n                }\n              } else {\n                const makeRecordLive =\n                  subscriptions && isTableLike && returnTypeTable && liveRecord\n                    ? record => {\n                        if (record) {\n                          liveRecord(\n                            \"pg\",\n                            returnTypeTable,\n                            record.__identifiers\n                          );\n                        }\n                      }\n                    : _record => {};\n                if (proc.returnsSet && !isMutation && !forceList) {\n                  // Connection - do not make live (the connection will handle this)\n                  return addStartEndCursor({\n                    ...value,\n                    data: value.data ? value.data.map(scalarAwarePg2gql) : null,\n                  });\n                } else if (proc.returnsSet || rawReturnType.isPgArray) {\n                  // List\n                  const records = value.map(v => {\n                    makeRecordLive(v);\n                    return pg2gql(v, returnType);\n                  });\n                  return records;\n                } else {\n                  // Object\n                  if (value) {\n                    makeRecordLive(value);\n                  }\n                  return pg2gql(value, returnType);\n                }\n              }\n            }\n          : async (data, args, resolveContext, resolveInfo) => {\n              const { pgClient } = resolveContext;\n              const liveRecord =\n                resolveInfo.rootValue && resolveInfo.rootValue.liveRecord;\n              const parsedResolveInfoFragment = parseResolveInfo(resolveInfo);\n              parsedResolveInfoFragment.args = args; // Allow overriding via makeWrapResolversPlugin\n              const functionAlias = sql.identifier(Symbol());\n              const sqlFunctionCall = makeSqlFunctionCall(\n                parsedResolveInfoFragment.args,\n                {\n                  unnest: rawReturnType.isPgArray,\n                }\n              );\n\n              let queryResultRows;\n              if (isMutation) {\n                const query = makeQuery(\n                  parsedResolveInfoFragment,\n                  resolveInfo.returnType,\n                  functionAlias,\n                  functionAlias,\n                  null,\n                  resolveContext,\n                  resolveInfo\n                );\n                const intermediateIdentifier = sql.identifier(Symbol());\n                const isVoid = returnType.id === \"2278\";\n                const isPgRecord = returnType.id === \"2249\";\n                const isPgClass =\n                  !isPgRecord &&\n                  (!returnFirstValueAsValue || returnTypeTable || false);\n                try {\n                  await pgClient.query(\"SAVEPOINT graphql_mutation\");\n                  queryResultRows = await viaTemporaryTable(\n                    pgClient,\n                    isVoid\n                      ? null\n                      : sql.identifier(\n                          returnType.namespaceName,\n                          returnType.name\n                        ),\n                    sql.query`select ${\n                      isPgClass\n                        ? sql.query`${intermediateIdentifier}.*`\n                        : isPgRecord\n                        ? sql.query`${intermediateIdentifier}.*`\n                        : sql.query`${intermediateIdentifier} as ${functionAlias}`\n                    } from ${sqlFunctionCall} ${intermediateIdentifier}`,\n                    functionAlias,\n                    query,\n                    isPgClass,\n                    isPgRecord\n                      ? {\n                          outputArgTypes,\n                          outputArgNames,\n                        }\n                      : null\n                  );\n                  await pgClient.query(\"RELEASE SAVEPOINT graphql_mutation\");\n                } catch (e) {\n                  await pgClient.query(\n                    \"ROLLBACK TO SAVEPOINT graphql_mutation\"\n                  );\n                  throw e;\n                }\n              } else {\n                const query = makeQuery(\n                  parsedResolveInfoFragment,\n                  resolveInfo.returnType,\n                  sqlFunctionCall,\n                  functionAlias,\n                  null,\n                  resolveContext,\n                  resolveInfo\n                );\n                const { text, values } = sql.compile(query);\n                if (debugSql.enabled) debugSql(text);\n                const queryResult = await pgPrepareAndRun(\n                  pgClient,\n                  text,\n                  values\n                );\n                queryResultRows = queryResult.rows;\n              }\n              const rows = queryResultRows;\n              const [row] = rows;\n              const result = (() => {\n                const makeRecordLive =\n                  subscriptions && isTableLike && returnTypeTable && liveRecord\n                    ? record => {\n                        if (record) {\n                          liveRecord(\n                            \"pg\",\n                            returnTypeTable,\n                            record.__identifiers\n                          );\n                        }\n                      }\n                    : _record => {};\n                if (returnFirstValueAsValue) {\n                  // `returnFirstValueAsValue` implies either `isMutation` is\n                  // true, or `ConnectionType` does not exist - either way,\n                  // we're not returning a connection.\n                  if (proc.returnsSet && !isMutation && !forceList) {\n                    return row.data.map(v => {\n                      const fv = firstValue(v);\n                      makeRecordLive(fv);\n                      return pg2gql(fv, returnType);\n                    });\n                  } else if (proc.returnsSet || rawReturnType.isPgArray) {\n                    return rows.map(v => {\n                      const fv = firstValue(v);\n                      makeRecordLive(fv);\n                      return pg2gql(fv, returnType);\n                    });\n                  } else {\n                    const fv = firstValue(row);\n                    makeRecordLive(fv);\n                    const record = pg2gql(fv, returnType);\n                    return record;\n                  }\n                } else {\n                  if (proc.returnsSet && !isMutation && !forceList) {\n                    // Connection\n                    const data = row.data\n                      ? row.data.map(scalarAwarePg2gql)\n                      : null;\n                    return addStartEndCursor({\n                      ...row,\n                      data,\n                    });\n                  } else if (proc.returnsSet || rawReturnType.isPgArray) {\n                    // List\n                    return rows.map(row => {\n                      makeRecordLive(row);\n                      return pg2gql(row, returnType);\n                    });\n                  } else {\n                    // Object\n                    makeRecordLive(row);\n                    return pg2gql(row, returnType);\n                  }\n                }\n              })();\n              if (isMutation) {\n                return {\n                  clientMutationId: args.input.clientMutationId,\n                  data: result,\n                };\n              } else {\n                return result;\n              }\n            },\n      };\n    },\n    fieldScope\n  );\n}\n"],"file":"makeProcField.js"}