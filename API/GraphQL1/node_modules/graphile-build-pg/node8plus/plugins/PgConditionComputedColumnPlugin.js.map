{"version":3,"sources":["../../src/plugins/PgConditionComputedColumnPlugin.js"],"names":["getCompatibleComputedColumns","build","table","pgIntrospectionResultsByKind","introspectionResultsByKind","pgOmit","omit","procedure","reduce","memo","proc","tags","filterable","computedColumnDetails","pseudoColumnName","nonOptionalArgumentsCount","inputArgsCount","argDefaultsNum","returnsSet","returnType","typeById","returnTypeId","isPgArray","returnTypeTable","classById","classId","isRecordLike","id","isVoid","String","push","PgConditionComputedColumnPlugin","builder","hook","fields","context","extend","pgGetGqlInputTypeByTypeIdAndModifier","inflection","describePgEntity","scope","isPgCondition","pgIntrospection","fieldWithHooks","kind","compatibleComputedColumns","fieldName","computedColumn","Type","description","wrapDescription","type","isPgConnectionConditionInputField","pgFieldIntrospection","args","pgSql","sql","gql2pg","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","graphql","getNullableType","isPgFieldConnection","isPgFieldSimpleCollection","pgFieldIntrospectionTable","addArgDataGenerator","shouldAddCondition","condition","namespace","TableType","TableConditionType","conditionType","name","map","o","sqlFnName","identifier","namespaceName","connectionCondition","pgQuery","queryBuilder","forEach","val","sqlCall","fragment","getTableAlias","where"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nimport { getComputedColumnDetails } from \"./PgComputedColumnsPlugin\";\nimport assert from \"assert\";\nfunction getCompatibleComputedColumns(build, table) {\n  const {\n    pgIntrospectionResultsByKind: introspectionResultsByKind,\n    pgOmit: omit,\n  } = build;\n  return introspectionResultsByKind.procedure.reduce((memo, proc) => {\n    /* ALSO SEE PgOrderComputedColumnsPlugin */\n    // Must be marked @filterable\n    if (!proc.tags.filterable) return memo;\n\n    // Must not be omitted\n    if (omit(proc, \"execute\")) return memo;\n\n    // Must be a computed column\n    const computedColumnDetails = getComputedColumnDetails(build, table, proc);\n    if (!computedColumnDetails) return memo;\n    const { pseudoColumnName } = computedColumnDetails;\n\n    // Must have only one required argument\n    const nonOptionalArgumentsCount = proc.inputArgsCount - proc.argDefaultsNum;\n    if (nonOptionalArgumentsCount > 1) {\n      return memo;\n    }\n\n    // Must return a scalar\n    if (proc.returnsSet) return memo;\n    const returnType = introspectionResultsByKind.typeById[proc.returnTypeId];\n    if (returnType.isPgArray) return memo;\n    const returnTypeTable =\n      introspectionResultsByKind.classById[returnType.classId];\n    if (returnTypeTable) return memo;\n    const isRecordLike = returnType.id === \"2249\";\n    if (isRecordLike) return memo;\n    const isVoid = String(returnType.id) === \"2278\";\n    if (isVoid) return memo;\n\n    // Looks good\n    memo.push({ proc, pseudoColumnName, returnType });\n    return memo;\n  }, []);\n}\n\nexport default (function PgConditionComputedColumnPlugin(builder) {\n  builder.hook(\n    \"GraphQLInputObjectType:fields\",\n    (fields, build, context) => {\n      const {\n        extend,\n        pgGetGqlInputTypeByTypeIdAndModifier,\n        inflection,\n        describePgEntity,\n      } = build;\n      const {\n        scope: { isPgCondition, pgIntrospection: table },\n        fieldWithHooks,\n      } = context;\n      if (!isPgCondition || !table || table.kind !== \"class\") {\n        return fields;\n      }\n      const compatibleComputedColumns = getCompatibleComputedColumns(\n        build,\n        table\n      );\n      return extend(\n        fields,\n        compatibleComputedColumns.reduce((memo, { proc, pseudoColumnName }) => {\n          const fieldName = inflection.computedColumn(\n            pseudoColumnName,\n            proc,\n            table\n          );\n          const Type = pgGetGqlInputTypeByTypeIdAndModifier(\n            proc.returnTypeId,\n            null\n          );\n          if (!Type) return memo;\n          memo = build.extend(\n            memo,\n            {\n              [fieldName]: fieldWithHooks(\n                fieldName,\n                {\n                  description: build.wrapDescription(\n                    `Checks for equality with the objectâ€™s \\`${fieldName}\\` field.`,\n                    \"field\"\n                  ),\n                  type: Type,\n                },\n                {\n                  isPgConnectionConditionInputField: true,\n                  pgFieldIntrospection: proc,\n                }\n              ),\n            },\n            `Adding computed column condition argument for ${describePgEntity(\n              proc\n            )}`\n          );\n          return memo;\n        }, {})\n      );\n    },\n    [\"PgConditionComputedColumn\"]\n  );\n\n  builder.hook(\n    \"GraphQLObjectType:fields:field:args\",\n    (args, build, context) => {\n      const {\n        pgSql: sql,\n        gql2pg,\n        getTypeByName,\n        pgGetGqlTypeByTypeIdAndModifier,\n        inflection,\n        pgOmit: omit,\n        graphql: { getNullableType },\n      } = build;\n      const {\n        scope: {\n          isPgFieldConnection,\n          isPgFieldSimpleCollection,\n          pgFieldIntrospection,\n          pgFieldIntrospectionTable,\n        },\n        addArgDataGenerator,\n      } = context;\n\n      const shouldAddCondition =\n        isPgFieldConnection || isPgFieldSimpleCollection;\n      if (!shouldAddCondition) return args;\n      if (!args.condition) {\n        return args;\n      }\n      const proc =\n        pgFieldIntrospection.kind === \"procedure\" ? pgFieldIntrospection : null;\n      const table =\n        pgFieldIntrospection.kind === \"class\"\n          ? pgFieldIntrospection\n          : proc\n          ? pgFieldIntrospectionTable\n          : null;\n      if (\n        !table ||\n        table.kind !== \"class\" ||\n        !table.namespace ||\n        omit(table, \"filter\")\n      ) {\n        return args;\n      }\n      const TableType = pgGetGqlTypeByTypeIdAndModifier(table.type.id, null);\n      const TableConditionType = getTypeByName(\n        inflection.conditionType(TableType.name)\n      );\n      if (!TableConditionType) {\n        return args;\n      }\n      assert(\n        getNullableType(args.condition.type) === TableConditionType,\n        \"Condition is present, but doesn't match?\"\n      );\n\n      const compatibleComputedColumns = getCompatibleComputedColumns(\n        build,\n        table\n      ).map(o => {\n        const { proc, pseudoColumnName } = o;\n\n        const fieldName = inflection.computedColumn(\n          pseudoColumnName,\n          proc,\n          table\n        );\n        const sqlFnName = sql.identifier(proc.namespaceName, proc.name);\n        return {\n          ...o,\n          fieldName,\n          sqlFnName,\n        };\n      });\n      addArgDataGenerator(function connectionCondition({ condition }) {\n        return {\n          pgQuery: queryBuilder => {\n            if (condition != null) {\n              compatibleComputedColumns.forEach(\n                ({ fieldName, sqlFnName, returnType }) => {\n                  const val = condition[fieldName];\n                  const sqlCall = sql.fragment`${sqlFnName}(${queryBuilder.getTableAlias()})`;\n                  if (val != null) {\n                    queryBuilder.where(\n                      sql.fragment`${sqlCall} = ${gql2pg(\n                        val,\n                        returnType,\n                        null\n                      )}`\n                    );\n                  } else if (val === null) {\n                    queryBuilder.where(sql.fragment`${sqlCall} IS NULL`);\n                  }\n                }\n              );\n            }\n          },\n        };\n      });\n\n      return args;\n    },\n    [\"PgConditionComputedColumn\"]\n  );\n}: Plugin);\n"],"file":"PgConditionComputedColumnPlugin.js"}