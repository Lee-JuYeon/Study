{"version":3,"sources":["../src/callbackToAsyncIterator.js"],"names":["defaultOnError","err","callbackToAsyncIterator","listener","options","onError","buffering","onClose","pullQueue","pushQueue","listening","listenerReturnValue","pushValue","value","length","shift","done","push","pullValue","Promise","resolve","emptyQueue","forEach","undefined","then","a","catch","next","return","throw","error","reject","$$asyncIterator"],"mappings":";;;;;;;AAMA;;AALA;AACA;AACA;AACA;AACA;AAGA,MAAMA,cAAc,GAAIC,GAAD,IAAgB;AACrC,QAAMA,GAAN;AACD,CAFD;;AAIe,SAASC,uBAAT,CAIbC,QAJa,EAKbC,OAIC,GAAG,EATS,EAUb;AACA,QAAM;AAAEC,IAAAA,OAAO,GAAGL,cAAZ;AAA4BM,IAAAA,SAAS,GAAG,IAAxC;AAA8CC,IAAAA;AAA9C,MAA0DH,OAAhE;AACA,MAAII,SAAS,GAAG,EAAhB;AACA,MAAIC,SAAS,GAAG,EAAhB;AACA,MAAIC,SAAS,GAAG,IAAhB;AACA,MAAIC,mBAAJ;;AAEA,WAASC,SAAT,CAAmBC,KAAnB,EAA0B;AACxB,QAAIL,SAAS,CAACM,MAAV,KAAqB,CAAzB,EAA4B;AAC1BN,MAAAA,SAAS,CAACO,KAAV,GAAkB;AAAEF,QAAAA,KAAF;AAASG,QAAAA,IAAI,EAAE;AAAf,OAAlB;AACD,KAFD,MAEO,IAAIV,SAAS,KAAK,IAAlB,EAAwB;AAC7BG,MAAAA,SAAS,CAACQ,IAAV,CAAeJ,KAAf;AACD;AACF;;AAED,WAASK,SAAT,GAAqB;AACnB,WAAO,IAAIC,OAAJ,CAAYC,OAAO,IAAI;AAC5B,UAAIX,SAAS,CAACK,MAAV,KAAqB,CAAzB,EAA4B;AAC1BM,QAAAA,OAAO,CAAC;AAAEP,UAAAA,KAAK,EAAEJ,SAAS,CAACM,KAAV,EAAT;AAA4BC,UAAAA,IAAI,EAAE;AAAlC,SAAD,CAAP;AACD,OAFD,MAEO;AACLR,QAAAA,SAAS,CAACS,IAAV,CAAeG,OAAf;AACD;AACF,KANM,CAAP;AAOD;;AAED,WAASC,UAAT,GAAsB;AACpB,QAAIX,SAAJ,EAAe;AACbA,MAAAA,SAAS,GAAG,KAAZ;AACAF,MAAAA,SAAS,CAACc,OAAV,CAAkBF,OAAO,IAAIA,OAAO,CAAC;AAAEP,QAAAA,KAAK,EAAEU,SAAT;AAAoBP,QAAAA,IAAI,EAAE;AAA1B,OAAD,CAApC;AACAR,MAAAA,SAAS,GAAG,EAAZ;AACAC,MAAAA,SAAS,GAAG,EAAZ;AACAF,MAAAA,OAAO,IAAIA,OAAO,CAACI,mBAAD,CAAlB;AACD;AACF;;AAED,MAAI;AACF;AACAQ,IAAAA,OAAO,CAACC,OAAR,CAAgBjB,QAAQ,CAACU,KAAK,IAAID,SAAS,CAACC,KAAD,CAAnB,CAAxB,EACGW,IADH,CACQC,CAAC,IAAI;AACTd,MAAAA,mBAAmB,GAAGc,CAAtB;AACD,KAHH,EAIGC,KAJH,CAISzB,GAAG,IAAI;AACZI,MAAAA,OAAO,CAACJ,GAAD,CAAP;AACD,KANH;AAQA,WAAO;AACL0B,MAAAA,IAAI,GAAsD;AACxD,eAAOjB,SAAS,GAAGQ,SAAS,EAAZ,GAAiB,KAAKU,MAAL,EAAjC;AACD,OAHI;;AAILA,MAAAA,MAAM,GAAwD;AAC5DP,QAAAA,UAAU;AACV,eAAOF,OAAO,CAACC,OAAR,CAAgB;AAAEP,UAAAA,KAAK,EAAEU,SAAT;AAAoBP,UAAAA,IAAI,EAAE;AAA1B,SAAhB,CAAP;AACD,OAPI;;AAQLa,MAAAA,KAAK,CAACC,KAAD,EAAe;AAClBT,QAAAA,UAAU;AACVhB,QAAAA,OAAO,CAACyB,KAAD,CAAP;AACA,eAAOX,OAAO,CAACY,MAAR,CAAeD,KAAf,CAAP;AACD,OAZI;;AAaL,OAACE,wBAAD,IAAoB;AAClB,eAAO,IAAP;AACD;;AAfI,KAAP;AAiBD,GA3BD,CA2BE,OAAO/B,GAAP,EAAY;AACZI,IAAAA,OAAO,CAACJ,GAAD,CAAP;AACA,WAAO;AACL0B,MAAAA,IAAI,GAAG;AACL,eAAOR,OAAO,CAACY,MAAR,CAAe9B,GAAf,CAAP;AACD,OAHI;;AAIL2B,MAAAA,MAAM,GAAG;AACP,eAAOT,OAAO,CAACY,MAAR,CAAe9B,GAAf,CAAP;AACD,OANI;;AAOL4B,MAAAA,KAAK,CAACC,KAAD,EAAe;AAClB,eAAOX,OAAO,CAACY,MAAR,CAAeD,KAAf,CAAP;AACD,OATI;;AAUL,OAACE,wBAAD,IAAoB;AAClB,eAAO,IAAP;AACD;;AAZI,KAAP;AAcD;AACF","sourcesContent":["// @flow\n/* eslint-disable flowtype/no-weak-types */\n// Turn a callback-based listener into an async iterator\n// From https://raw.githubusercontent.com/withspectrum/callback-to-async-iterator/master/src/index.js\n// License MIT (Copyright (c) 2017 Maximilian Stoiber)\n// Based on https://github.com/apollographql/graphql-subscriptions/blob/master/src/event-emitter-to-async-iterator.ts\nimport { $$asyncIterator } from \"iterall\";\n\nconst defaultOnError = (err: Error) => {\n  throw err;\n};\n\nexport default function callbackToAsyncIterator<\n  CallbackInput: any,\n  ReturnVal: any\n>(\n  listener: ((arg: CallbackInput) => any) => ?ReturnVal | Promise<?ReturnVal>,\n  options?: {\n    onError?: (err: Error) => void,\n    onClose?: (arg?: ?ReturnVal) => void,\n    buffering?: boolean,\n  } = {}\n) {\n  const { onError = defaultOnError, buffering = true, onClose } = options;\n  let pullQueue = [];\n  let pushQueue = [];\n  let listening = true;\n  let listenerReturnValue;\n\n  function pushValue(value) {\n    if (pullQueue.length !== 0) {\n      pullQueue.shift()({ value, done: false });\n    } else if (buffering === true) {\n      pushQueue.push(value);\n    }\n  }\n\n  function pullValue() {\n    return new Promise(resolve => {\n      if (pushQueue.length !== 0) {\n        resolve({ value: pushQueue.shift(), done: false });\n      } else {\n        pullQueue.push(resolve);\n      }\n    });\n  }\n\n  function emptyQueue() {\n    if (listening) {\n      listening = false;\n      pullQueue.forEach(resolve => resolve({ value: undefined, done: true }));\n      pullQueue = [];\n      pushQueue = [];\n      onClose && onClose(listenerReturnValue);\n    }\n  }\n\n  try {\n    // Start listener\n    Promise.resolve(listener(value => pushValue(value)))\n      .then(a => {\n        listenerReturnValue = a;\n      })\n      .catch(err => {\n        onError(err);\n      });\n\n    return {\n      next(): Promise<{ value?: CallbackInput, done: boolean }> {\n        return listening ? pullValue() : this.return();\n      },\n      return(): Promise<{ value: typeof undefined, done: boolean }> {\n        emptyQueue();\n        return Promise.resolve({ value: undefined, done: true });\n      },\n      throw(error: Error) {\n        emptyQueue();\n        onError(error);\n        return Promise.reject(error);\n      },\n      [$$asyncIterator]() {\n        return this;\n      },\n    };\n  } catch (err) {\n    onError(err);\n    return {\n      next() {\n        return Promise.reject(err);\n      },\n      return() {\n        return Promise.reject(err);\n      },\n      throw(error: Error) {\n        return Promise.reject(error);\n      },\n      [$$asyncIterator]() {\n        return this;\n      },\n    };\n  }\n}\n"],"file":"callbackToAsyncIterator.js"}