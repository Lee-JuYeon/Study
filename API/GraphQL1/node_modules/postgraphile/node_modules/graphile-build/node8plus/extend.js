"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extend;
exports.indent = indent;

var _chalk = _interopRequireDefault(require("chalk"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const INDENT = "  ";
const $$hints = Symbol("hints");

function indent(text) {
  return INDENT + text.replace(/\n/g, "\n" + INDENT).replace(/\n +(?=\n|$)/g, "\n");
}

function extend(base, extra, hint) {
  const hints = base[$$hints] || {};
  const keysB = Object.keys(extra);
  const extraHints = extra[$$hints] || {};

  for (const key of keysB) {
    const newValue = extra[key];
    const hintB = extraHints[key] || hint;

    if (key in base && base[key] !== newValue) {
      const hintA = hints[key];
      const firstEntityDetails = !hintA ? "We don't have any information about the first entity." : `The first entity was:\n\n${indent(_chalk.default.magenta(hintA))}`;
      const secondEntityDetails = !hintB ? "We don't have any information about the second entity." : `The second entity was:\n\n${indent(_chalk.default.yellow(hintB))}`;
      throw new Error(`A naming conflict has occurred - two entities have tried to define the same key '${_chalk.default.bold(key)}'.\n\n${indent(firstEntityDetails)}\n\n${indent(secondEntityDetails)}`);
    }

    if (hintB) {
      hints[key] = hintB;
    }
  }

  return Object.assign(base, extra, {
    // $FlowFixMe: symbols
    [$$hints]: hints
  });
}
//# sourceMappingURL=extend.js.map